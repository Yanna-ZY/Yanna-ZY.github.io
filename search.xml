<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-OS-lab0</title>
      <link href="/2023/03/19/BUAA-OS-0/"/>
      <url>/2023/03/19/BUAA-OS-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab0实验报告"><a href="#Lab0实验报告" class="headerlink" title="Lab0实验报告"></a>Lab0实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><blockquote><p>思考下列有关 Git 的问题： </p><p>• 在前述已初始化的 ~&#x2F;learnGit 目录下，创建一个名为 README.txt 的文件。 执行命令 git status &gt; Untracked.txt。 </p><p>• 在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git status &gt; Stage.txt。</p><p>• 提交 README.txt，并在提交说明里写入自己的学号。</p><p>• 执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体 会 README.txt 两次所处位置的不同。 </p><p>• 修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。</p><p>• 执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是否一样，并思考原因。</p></blockquote><ul><li>解：<ul><li>执行<code>git status &gt; Untracked.txt</code> ，表示查询当前<code>README.txt</code>文件状态，并将其记录在<code>Untracked.txt</code>文件中；<code>git status &gt; Stage.txt</code>和<code>git status &gt; Modified.txt</code> 同理。</li><li><code>cat Untracked.txt</code>后，第二行显示<code>Untracked files:</code>，说明：在 <code>README.txt</code> 新建的时候，其处于为未跟踪状态 （untracked）；</li><li><code>cat Stage.txt</code>后，第二行显示<code> Changes to be committed:</code>，说明：在 <code>README.txt</code> 中任意添加内容，接着用 add 命令之后，文件处于暂存状 态（staged）；</li><li><code>cat Modified.txt</code>后，第二行显示<code> Changes not staged for commit:</code>，说明：在修改 <code>README.txt</code> 之后，其处于被修改状态（modified）。</li></ul></li></ul><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><blockquote><p>仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？ </p></blockquote><img src="https://pic.imgdb.cn/item/6415e371a682492fcc343468.png" alt="image-20230306110135570" style="zoom: 67%;" /><ul><li>解：<ul><li>add the file ： <code>git add</code></li><li>stage the file：<code>git add</code></li><li>commit：&#96;git commit</li></ul></li></ul><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><blockquote><p>思考下列问题： </p><ol><li>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ </li><li>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？ </li><li>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下 将其移出暂存区？</li></ol></blockquote><ul><li>解：<ol><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm --cached print.c</code></li></ol></li></ul><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><blockquote><p>思考下列有关 Git 的问题： </p><p>• 找到在&#x2F;home&#x2F;21xxxxxx&#x2F;learnGit 下刚刚创建的 README.txt 文件，若不存 在则新建该文件。 </p><p>• 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。 </p><p>• 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。 </p><p>• 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值a。 </p><p>• 进行版本回退。执行命令 git reset –hard HEAD^后，再执行 git log，观 察其变化。 </p><p>• 找到提交说明为 1 的哈希值，执行命令 git reset –hard  后，再执 行 git log，观察其变化。 </p><p>• 现在已经回到了旧版本，为了再次回到新版本，执行 git reset –hard  ，再执行 git log，观察其变化。</p></blockquote><ul><li>解：<ul><li>第一次<code>git log</code><img src="https://pic.imgdb.cn/item/6415e38fa682492fcc346eba.png" alt="image-20230306112449617" style="zoom:67%;" /></li><li>第二次<code>git log</code><img src="https://pic.imgdb.cn/item/6415e3a6a682492fcc349dfa.png" alt="image-20230306112721493" style="zoom:67%;" /></li><li>第三次<code>git log</code> <img src="https://pic.imgdb.cn/item/6415e3baa682492fcc34c486.png" alt="image-20230306113023778" style="zoom:67%;" /></li><li>第四次<code>git log</code><img src="https://pic.imgdb.cn/item/6415e3d1a682492fcc34efa4.png" alt="image-20230306113216618" style="zoom:67%;" /></li></ul></li></ul><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><blockquote><p>执行如下命令, 并查看结果 </p><p>• echo first </p><p>• echo second &gt; output.txt </p><p>• echo third &gt; output.txt </p><p>• echo forth &gt;&gt; output.txt</p></blockquote><ul><li>解：<ul><li><img src="https://pic.imgdb.cn/item/6415e3eca682492fcc352290.png" alt="image-20230306120619660" style="zoom: 67%;" /></li><li><img src="https://pic.imgdb.cn/item/6415e3fca682492fcc354142.png" alt="image-20230306120729380" style="zoom:67%;" /></li><li><img src="https://pic.imgdb.cn/item/6415e418a682492fcc357a01.png" alt="image-20230306120809430" style="zoom:67%;" /></li><li><img src="https://pic.imgdb.cn/item/6415e42aa682492fcc359c34.png" alt="image-20230306120841658" style="zoom:67%;" /></li></ul></li></ul><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><blockquote><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test）， 将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行， 将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最 后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问 题: echo echo Shell Start 与 echo <code>echo Shell Start</code>效果是否有区别; echo echo $c&gt;file1 与 echo <code>echo $c&gt;file1</code>效果是否有区别. </p></blockquote><ul><li><p>解：</p><ul><li><p>command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash                                                              <span class="built_in">touch</span> <span class="built_in">test</span></span></span><br><span class="line">echo &#x27;echo Shell Start...&#x27; &gt; test</span><br><span class="line">echo &#x27;echo set a = 1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;a=1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set b = 2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;b=2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set c = a+b&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;c=$[$a+$b]&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo c = $c&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save c to ./file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $c&gt;file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save b to ./file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $b&gt;file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save a to ./file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $a&gt;file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file1 file2 file3 to file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file1&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file2&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file3&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file4 to ./result&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file4&gt;&gt;result&#x27; &gt;&gt; test</span><br></pre></td></tr></table></figure></li><li><p>result:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><ol><li><ul><li><p><code>echo echo Shell Start</code> 直接把“<code>echo Shell Start</code>” 作为字符串输出；</p></li><li><p><code>echo (反顿号)echo Shell Start(反顿号)</code>是将 “<code>echo Shell Start</code>” 的<strong>输出</strong>作为 外层echo 的输入，故会输出 <code>Shell Start</code>；</p></li><li><p><code>echo (单引号)echo Shell Start(单引号)</code>直接把“<code>echo Shell Start</code>” 作为字符串输出。</p></li></ul></li><li><ul><li><p><code>echo echo $c&gt;file1</code> 直接把“<code>echo $c&gt;file1</code>” 作为字符串输出；</p></li><li><p><code>echo (反顿号)echo $c&gt;file1(反顿号)</code>是将 “<code>echo $c&gt;file1</code>” 的<strong>输出</strong>作为 外层echo 的输入，故会输出 <code>$c&gt;file1</code>；</p></li><li><p><code>echo (单引号)echo $c&gt;file1(单引号)</code>直接把“<code>$c&gt;file1</code>” 作为字符串输出。</p></li></ul></li></ol></li></ul></li></ul><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a><a id="难点分析">难点分析</a></h2><p>对于实验中的难点，可用示意图、流程图或思维导图的方式来表述清楚。</p><h3 id="Exercise-0-1"><a href="#Exercise-0-1" class="headerlink" title="Exercise 0.1"></a>Exercise 0.1</h3><ol start="2"><li>由<code>.c</code>文件得到可执行文件：<code>gcc -o palindrome palindrome.c</code></li><li>提取<code>AAA</code>文件的第8行到<code>BBB</code>文件中：<code>sed -n &#39;8p&#39; AAA &gt; BBB</code> (安静模式，且仅输出不编辑)</li></ol><h3 id="Exercise-0-2"><a href="#Exercise-0-2" class="headerlink" title="Exercise 0.2"></a>Exercise 0.2</h3><p>   用shell删除叫做<code>file70</code>~&#96;file100<code>的子目录：</code>rm -r .&#x2F;“file$a”&#96;($a是shell中的变量)</p><p>重命名<code>filexx</code>为<code>newfilexx</code>：<code>mv ./&quot;file$a&quot; ./&quot;newfile$a&quot;</code></p><p>让变量<code>$a</code>递增：<code>let a=a+1</code></p><h3 id="Exercise-0-3"><a href="#Exercise-0-3" class="headerlink" title="Exercise 0.3"></a>Exercise 0.3</h3><p>   输出文件<code>file</code>中所有含有<code>sign </code>字符串的行号到文件<code>answer</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">touch helpfile #another file help me to finsh</span><br><span class="line">grep -n sign file &gt; helpfile </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">print</span> the number of line with <span class="string">&quot;sign&quot;</span> and its content to helpfile</span></span><br><span class="line">awk -F: &#x27;&#123;print $1&#125;&#x27; helpfile &gt; answer</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 输出以<span class="string">&quot;:&quot;</span>为分隔符的第一个字符串</span></span><br></pre></td></tr></table></figure><h3 id="Exercise-0-4"><a href="#Exercise-0-4" class="headerlink" title="Exercise 0.4"></a>Exercise 0.4</h3><ol><li><p>把<code>file</code>文件中的所有<code>wrong</code>字符串全部替换成<code>correct</code>字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/wrong/correct/g&quot; file </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-i只编辑不输出  /g把每一个都这样替换，而不是仅仅每行第一个</span></span><br></pre></td></tr></table></figure></li><li><ul><li><p><code>main.c</code>会调用<code>fibo.c</code>文件，预处理、编译、汇编、链接步骤如下：</p><ol><li><p>预处理、编译、汇编</p><p><code>fibo.c</code>的头文件放在<code>../include</code>目录里面，则生成<code>fibo.o</code>和<code>main.o</code>的<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种写法：</span></span><br><span class="line"><span class="section">all: fibo main</span></span><br><span class="line"></span><br><span class="line"><span class="section">fibo: fibo.c</span></span><br><span class="line">gcc -E fibo.c -o fibo.i</span><br><span class="line">gcc -S fibo.i -o fibo.s</span><br><span class="line">gcc -c fibo.s -o fibo.o</span><br><span class="line">rm fibo.i</span><br><span class="line">rm fibo.s</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.c fibo.o</span></span><br><span class="line">gcc -E main.c -o main.i -I ../<span class="keyword">include</span>  <span class="comment">#Attention！</span></span><br><span class="line">gcc -S main.i -o main.s</span><br><span class="line">gcc -c main.s -o main.o</span><br><span class="line">rm main.i</span><br><span class="line">rm main.s</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种写法（精简）：</span></span><br><span class="line"><span class="section">all: fibo main</span></span><br><span class="line"></span><br><span class="line"><span class="section">fibo: fibo.c</span></span><br><span class="line">gcc -c fibo.c</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.c fibo.o</span></span><br><span class="line">gcc -c main.c -I ../<span class="keyword">include</span>  <span class="comment">#Attention！</span></span><br></pre></td></tr></table></figure></li><li><p>链接</p><p>生成可执行文件<code>Main</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc fibo.o main.o -o Main</span><br></pre></td></tr></table></figure></li></ol></li><li><p>在 <code>csc</code> 目录下通过命令 <code>make</code> 可在 <code>csc/code</code> 目录中利用<code>csc/code/Makefile</code>生成 <code>fibo.o</code>、<code>main.o</code>，在 <code>csc</code> 目录中 生成可执行文件 <code>fibo</code>，再输入命令 <code>make clean</code> 后只删除两个<code>.o</code> 文件:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: fibo</span></span><br><span class="line"></span><br><span class="line"><span class="section">fibo: </span></span><br><span class="line">cd code &amp;&amp; make <span class="comment">#一定先cd，再make</span></span><br><span class="line">gcc ./code/fibo.o ./code/main.o -o fibo</span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">rm ./code/fibo.o</span><br><span class="line">rm ./code/main.o</span><br></pre></td></tr></table></figure><p><em><strong>【Attention：在 Makefile 中 cd 到其他目录，这个 cd 只能有效于当前一行，故而必须使用 “&amp;&amp;” 连接要在 cd 目录下的指令，写在同一行，同时不需要  cd ..&#x2F; 回来】</strong></em></p></li></ul></li></ol><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><p>写下实验过程中的体会。</p><p>​        本次实验我参考了一些学长学姐的<em>blog</em>，协助理解几种不同工具的使用，在这里引用<em><strong>Hyggge</strong></em>学长的一幅图，也是我认为几点对我来说有难度或者不熟悉的知识点：</p><p><img src="https://pic.imgdb.cn/item/6415e43da682492fcc35c0fb.png" alt="image-20230306133316915"></p><p>​       虽然Lab0课下实验的难度不大，但是仍然有许多小细节，具体我写在<a href="#%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90">难点分析</a>中了，课下实验总共花费了15个小时左右，中途也查询了许多资料，并且向同学大牛们请教颇多。</p><p>​       lab0-extra  我最后一个有关diff的操作错误了，正确代码应该是：</p><img src="C:\Users\Zhang Yang\AppData\Roaming\Typora\typora-user-images\image-20230306215954391.png" alt="image-20230306215954391" style="zoom:67%;" /><p>​      我错在写的<code>if [ $?  -eq  0 ]</code> <em><strong>Shell 中，对空格非常敏感，一定要在规定的不同符号间加空格，同时，在Shell中 0 表示真 ， 1 表示假！！与正常的编程语言相反！</strong></em></p><p>​       OS的实验课仍然是道阻且长。</p><h2 id="课上测试"><a href="#课上测试" class="headerlink" title="课上测试"></a>课上测试</h2><p>​        本次课上测试，我的<code>lab0-extra</code>只得了75分，反思确实是自己的相关知识点掌握不到位，因此我觉得是毫无怨言的。</p><p>​        但是稍微有些可惜的是，我和100分失之交臂的点：按照我原本的性格习惯，对于<code>$?</code>的返回值条件为<code>1或0</code>（后面会具体讲解），无论怎样我都会尝试一下两种情况的两种结果，但是，在考场上的时候，由于紧张和着急，我没有选择符合之前习惯的做法，其实只要我尝试一下，就是可以满分的，对此感到些许可惜，故而反思到——考场上的心态和冷静依旧是我要培养的点。</p><p>​        通过课后老师的讲解，和与其他同学的交流【主要是笨蛋的我向大牛们请教哇~】，可以发现<code>lab0</code>的课上测试，在<code>exam</code>和<code>extra</code>里面各有一个点卡着大家，这两点甚至老师也要思索一二才能想通，一下具体阐述：</p><h3 id="lab0-exam"><a href="#lab0-exam" class="headerlink" title="lab0-exam"></a>lab0-exam</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=10</span><br><span class="line"><span class="keyword">while</span> [  <span class="variable">$n</span> -gt 0  ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$n</span></span><br><span class="line">    <span class="built_in">let</span> n=n-1</span><br><span class="line"><span class="keyword">done</span>    </span><br></pre></td></tr></table></figure><p>​        上面这段程序在本地运行的时候是完全正确的，但是一旦提交到评测机上就会<strong>报错</strong>，原因是：</p><ul><li><p>​        1. 在<code>let</code>语句中，如果<code>=</code>右边的结果变成<strong>小于或等于0</strong>的数，那么该<code>let</code>语句的返回值<code>$?</code>的值就会变成1；</p><p>​        2. 而在<code>bash</code>中，整个程序的返回值<code>$?</code>&#x3D;最后一条语句的返回值<code>$?</code>；</p><p>​        3. 且在评测机中一旦程序的返回值<code>$?</code>为1，它就认为这个程序报错了；</p><p>​        故而，上述程序最后的返回值<code>$?</code>就是1，则报错。</p></li><li><p>可能的修改方式：</p><ul><li><pre><code class="bash">n=10i=1while [  $i -le $n  ]do    echo $i    let i=i+1done   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  n=10</span><br><span class="line">  while [  $n -gt 0  ]</span><br><span class="line">  do</span><br><span class="line">      echo $n</span><br><span class="line">      n=$((n-1))</span><br><span class="line">  done    </span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;bash<br>n&#x3D;10<br>while [  $n -gt 0  ]<br>do<br>echo $n<br>let n&#x3D;n-1<br>done<br>exit 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### lab0-extra</span><br><span class="line"></span><br><span class="line">#### diff</span><br><span class="line"></span><br><span class="line">- 当`diff A B`发现A和B有不同，那么该语句的返回值`$? -eq 1 `，并且会输出一定的文字；当A和B完全一样的时候，那么该语句的返回值`$? -eq 0 `，且不会有任何输出。</span><br><span class="line"></span><br><span class="line">- 题目代码为：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  diff $1 $3 &gt; /dev/null</span><br><span class="line">  if [  $? -eq 1  ] </span><br><span class="line">  then</span><br><span class="line">       echo different</span><br><span class="line">  else     </span><br><span class="line">       echo same</span><br><span class="line">  fi     </span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id=""><a href="#" class="headerlink" title="$?  $#"></a><code>$?</code>  <code>$#</code></h4><ul><li><code>$?</code>表示上一条语句的返回值</li><li><code>$#</code>表示传参个数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 养德（学习） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-第一单元：表达式展开</title>
      <link href="/2023/03/18/BUAA-OO-1/"/>
      <url>/2023/03/18/BUAA-OO-1/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OO-第一单元：表达式展开"><a href="#BUAA-OO-第一单元：表达式展开" class="headerlink" title="BUAA-OO-第一单元：表达式展开"></a>BUAA-OO-第一单元：表达式展开</h1><p>【小女子废话较多，总是“有感而发”地“抒情”，这些不重要的话用“【】”标注出来了，可以尽情跳过~】</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        这是本学期OO的起航，从实现的角度而言，我认为以下几种预习选择至少要有一种，否则第一周的作业会很难顺利完成：【学业是其次，主要是很毁心态哇~  开学暴击~】</p><ol><li>大二上学期<strong>OO先导课</strong>或者<strong>java课</strong>学习</li><li>大二寒假期间对于<strong>java语言</strong>的熟悉掌握，并且提前预习关于<strong>面向对象</strong>课程的知识点</li></ol><ul><li><p><em><strong>PS</strong></em>：</p><p>​          个人会比较推荐OO先导课，但是名额有限，许多同学会抢不到，这种情况下，可以向该课的助教老师申请“旁听”，即与选上的同学同步学习并完成作业，但是最后不会有学分。</p><p>【小女子就是走的“旁听”这条路，但是由于个人的懒惰，我的OO先导课学习非常模糊，也导致了第一单元作业完成得比较痛苦，望引以为戒~】</p></li></ul><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>​        本次作业需要完成的任务为：读入一个包含<code>+、-、*、^、()</code>的<strong>多变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。</p><ul><li><em><strong>PS</strong></em>：<ul><li>其中括号的深度<strong>至多为 1 层</strong></li><li>乘方也不是用<code>^</code>这样的单个符号表示，而是用的<code>**</code>双符号表示，这一点可以在预处理中完成替换【如果这一步不完成，问题也不大~  小女子又又是因为懒惰并没有替换，但是，不得不承认换了之后会看着很快乐~】</li><li>多变量只涉及<code>x,y,z</code></li><li>最终输出的表达式中不能含有<code>()</code></li><li>更多要求详见教程</li></ul></li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://pic.imgdb.cn/item/6412a088ebf10e5d53419f40.png" alt="image-20230307173309428"></p><h3 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expr   := Term   | Term   [+|-] Expr</span><br><span class="line">Term   := Factor | Factor [+|-] Term</span><br><span class="line">Factor := Expr   | NumFactor  | PowerFactor</span><br></pre></td></tr></table></figure><p>​        通过分析表达式，我们发现它主要包含三部分——<code>Expr</code>，<code>Term</code>，<code>Factor</code>，而<code>Factor</code>又有三种——<em>幂函数，常数因子和表达式因子</em>。</p><p>​        分析<code>Factor</code>时，我们发现它<strong>数据抽象层次</strong>重合度低，但是<strong>行为抽象层次</strong>重合度高，因此这里我们引入接口<code>Factor</code>，来方便使用<code>Expr,NumFactor,PowerFactor</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Factor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EXpr.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Expr</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumFactor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumFactor</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PowerFactor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerFactor</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>​        具体如何处理并输出除去括号后的表达式，我大致分为了三个步骤——<em>预处理、表达式解析、计算优化输出</em>，下面进行具体分析。</p><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>​         为了简化之后的步骤我进行了三大类预处理——去除空格，去连续的重复的[+|-]，增或减+和0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainClass.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    processer.delBlank();<span class="comment">//删掉空白符</span></span><br><span class="line">    processer.delPlusMinus();<span class="comment">//删掉多余重复的加减号，并删除首位的加号</span></span><br><span class="line">    processer.adjustSign();<span class="comment">//杂七杂八的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Processer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Processer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delPlusMinus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//删掉了连续的多个+-</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//删掉第一个字符为+的</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustSign</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//删掉无必要的+</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//给首位的-前面加0</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//给（后面接着的-前面加0</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delBlank</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【在<code>(</code> 和<code>-</code>之间加上0，是我debug时候发现的一种简化处理方式，又又又是为了偷懒，实在懒得思考<code>-</code>开头的处理方式了，个人觉得还挺好用的~】</p><h5 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h5><p>​        有大致两种主流方法进行表达式解析，分别是<strong>递归下降算法</strong>和<strong>正则表达式算法</strong>，众所周知正则表达式算法的<em>迭代性</em>在“表达式解析”中比较差，为了方便于接下来的嵌套括号、自定义函数等等迭代，这里推荐递归下降算法。</p><p>【当然，通过“严刑逼供”（采访）身边的同学~ 我发现用正则表达式算法的同学很少，多数使用的递归下降算法，只是可能局部会涉及正则表达式匹配，可以认为是<strong>递归下降+正则算法</strong>。但是由于小女子又又又又懒了~ 所以没有具体询问他们是在哪一块使用的正则，因此这里仅仅简述“递归下降算法”。】</p><p>​        递归下降算法的主要组成部分分别是——<code>Lexer</code>（词法分析器）和<code>Parser</code>（语法解析器）。相关代码在<code>Training</code>和<code>exam（第一周实验课）</code>中有给出简单的框架，我们可以在这个基础进行修改迭代。</p><h6 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h6><p>​        在本次作业中，表达式的基本语法单元的类型有 <code>NUM</code>, <code>X</code>,  <code>Y</code>,  <code>Z</code>, <code>MULTI</code>, <code>MINUS</code>, <code>EXP</code>, <code>PLUS</code>, <code>LP</code>, <code>RP</code>，我们将这些语法单元的类型用<code>TokenType</code>这一枚举类型来记录。</p><p>【仅仅是为了方便理解，和后续“优雅化”代码，可以无需这个类。哇吼~  又是<code>enum</code>呢~ 在数据结构课程中也出现过的它，小女子当时学得比较糊，这里稍微补了补知识点漏洞。】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TokenType</span> &#123;</span><br><span class="line">    NUM, X, Y, Z,</span><br><span class="line">    MULTI, MINUS, EXP, PLUS,</span><br><span class="line">    LP, RP, <span class="comment">//左括号和右括号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        具体的<code>Lexer</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lexer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; tokens;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;TokenType&gt; tokenTypes;</span><br><span class="line">    <span class="comment">//可以删掉这些数组,我这里用数组只是为了方便调试的时候观察</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lexer</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="built_in">this</span>.next();<span class="comment">//在初始化的时候，记得读到第一个词</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//删除多余的前导0</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//获得数字</span></span><br><span class="line">          <span class="comment">//.. </span></span><br><span class="line">        <span class="comment">//由于我之前删除多余前导0了，因此为了防止数字恰好为0时，返回空串，这里判断并加上一个“0”</span></span><br><span class="line">          <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == input.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> input.charAt(pos);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> &amp;&amp; input.charAt(pos + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//判断乘方，可以在预处理中加入替换成“^”,可以简化</span></span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h6><p>​       <code>Parser</code>类的设计主要是沿用了本单元练习题中的写法，将表达式的解析分成了三部分——<code>parseExpr()</code>, <code>parseTerm()</code>, <code>parseFactor()</code>，每一部分的解析都遵循形式化文法。</p><p>​       以<code>parseExpr()</code>为例，因为第一项之前可能带有符号，于是我们就先将符号（<code>+</code>或者<code>-</code>）解析出来，然后解析第1项。解析完第1项后，我们就可以直接使用<code>while</code>循环对后面的项依次进行解析。</p><p>​       但是，在我的语法解析中，为了不让指数影响<code>NumFactor</code>，我在<code>parseTerm()</code>和 <code>parseFactor()</code>分别得到下层函数返回值之后，立刻处理乘方，将其用<code>for</code>循环乘起来，<strong>注意此时相乘的因子或项，都要把它们的<code>exp（指数）</code>设置为1</strong>。</p><p>​       最后结构是<code>parseExpr()</code>调用 <code>parseTerm()</code>, <code>parseTerm()</code>调用 <code>parseFactor()</code>，<code>parseFactor()</code>调用<code>parseExpr()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parser.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> Expr <span class="title function_">parseExpr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Expr</span>();</span><br><span class="line">        expr.addTerm(parseTerm());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">while</span> (lexer.nowTokenType() == TokenType.PLUS || lexer.nowTokenType() == TokenType.MINUS) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            lexer.next();</span><br><span class="line">            <span class="type">Term</span> <span class="variable">term</span> <span class="operator">=</span> parseTerm();</span><br><span class="line">            <span class="comment">//可以再这里处理-的符号问题</span></span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">            expr.addTerm(term);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Term <span class="title function_">parseTerm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">parseFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lexer.nowTokenType() == TokenType.LP) &#123;</span><br><span class="line">            <span class="comment">//调用parseExpr()</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lexer.nowTokenType() ==  TokenType.NUM) &#123;</span><br><span class="line">            <span class="comment">//处理NumFactor</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理PowerFactor</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="计算优化输出"><a href="#计算优化输出" class="headerlink" title="计算优化输出"></a>计算优化输出</h5><p>​        本次作业的计算单元通过分析可以归纳成式子——$$Expr &#x3D; \sum a_ix^{n_i}$$</p><p>​        即我们可以把所有项和因子都化成单项式 $ax^n$ ，然后用这个单项式进行计算，最终化简为多项式。因此，这里我们再建立两个类——<code>Poly</code>（<strong>多项式类</strong>）和<code>Mono</code>（<strong>单项式类</strong>）。</p><p>【强烈建议这里就不要叫它<code>Mono</code>了，直接叫<code>Unit</code>类，免得后续迭代的时候，还要一个个小心改动（虽然可以<code>Ctrl+R</code>直接替换，但是我担心改错，还是一个个看了），小女子已经吃过这个苦了~】</p><h6 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h6><p>​       <code>Mono</code>类含有两个成员变量——<code>coe</code>和<code>exp</code>，分别代表<strong>系数</strong>和<strong>x的指数</strong>。然后还有<code>toString()</code>方法，将<code>Mono</code>转化成 *<em>“系数*底数*<em>指数”</em></em> 这种形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Mono.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mono</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger coe;</span><br><span class="line">    <span class="keyword">private</span> Integer expX;</span><br><span class="line">    <span class="keyword">private</span> Integer expY;</span><br><span class="line">    <span class="keyword">private</span> Integer expZ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono <span class="title function_">mulMono</span><span class="params">(Mono imono)</span> &#123; <span class="comment">//计算Mono相乘</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Mono</span>(<span class="built_in">this</span>.coe.multiply(imono.coe),</span><br><span class="line">                  <span class="built_in">this</span>.expX + imono.expX,</span><br><span class="line">                  <span class="built_in">this</span>.expY + imono.expY,</span><br><span class="line">                  <span class="built_in">this</span>.expZ + imono.expZ);</span><br><span class="line">        <span class="comment">//注意这里要求：既能得到值，又不会改变原来Mono的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将Mono转化成 “系数*底数**指数” 这种形式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Poly"><a href="#Poly" class="headerlink" title="Poly"></a>Poly</h6><p>​      <code>Poly</code>类里面，我定义了两个容器，分别是——<code>ArrayList</code>容器和<code>HashMap</code>容器，全都容纳一系列<code>Mono</code>，前者我用来方便输出，后者我用来方便计算。【这里没有必要设计两个容器，只是小女子脑子不灵光，总是喜欢<code>ArrayList</code>，但是它确实在计算时，不如<code>HashMap</code>好用~】</p><p>​       此外，还有<code>addPoly()</code>，<code>mulPoly()</code>和<code>powPoly()</code>等方法来实现多项式的运算。</p><p>​       最后，用<code>toString()</code>方法将解析到的<code>Poly</code>表达式转化为待输出的字符串形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Poly.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poly</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Mono&gt; monos;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,BigInteger&gt; monoMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Poly <span class="title function_">addPoly</span><span class="params">(Poly iterm)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Mono imono : iterm.monos) &#123;</span><br><span class="line">           <span class="comment">//用HashMap计算</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历HashMap monoMap，添加到ArrayList monos</span></span><br><span class="line">        <span class="built_in">this</span>.monos.clear();</span><br><span class="line">        Iterator&lt;String&gt; iterator = monoMap.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Poly</span> <span class="variable">poly</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poly</span>(<span class="built_in">this</span>.monos);</span><br><span class="line">        poly.setMonoMap(<span class="built_in">this</span>.monoMap);<span class="comment">//把HashMap monoMap 复制过去</span></span><br><span class="line">        <span class="keyword">return</span> poly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Poly <span class="title function_">mulPoly</span><span class="params">(Poly ifactor)</span> &#123;</span><br><span class="line">        <span class="comment">//定义为0*x**0*y**0*z**0的Poly</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">for</span> (Mono imono : ifactor.monos) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="built_in">this</span>.monos.size();i++) &#123;</span><br><span class="line">               <span class="comment">//一个个相乘再加起来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果有负项或者负因子相乘，用来把所有符号逆置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">for</span> (Mono imono : <span class="built_in">this</span>.monos) &#123;</span><br><span class="line">            <span class="comment">//注意要深拷贝！！尽量不要在toString()里面改变对象</span></span><br><span class="line">            <span class="comment">//分类输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止空串</span></span><br><span class="line">        <span class="keyword">if</span> (sb.toString().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">printXyz</span><span class="params">(StringBuilder sb,Mono imono)</span> &#123;</span><br><span class="line">        <span class="comment">//输出xyz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        剩下的问题就是，如何在递归下降算法解析完表达式之后，把它全部转为<code>Poly</code>类型。这里，我采用在<code>Expr</code>、<code>Term</code>、<code>Factor</code>等类中都写一个<code>toPoly()</code>方法，将类中的内容转化为多项式。</p><p>​       【本质上也是递归下降算法，小女子听闻有一些大牛是合并了两个递归下降的，但是由于自己的笨笨和又又又又又懒懒，没有特别了解清楚。】</p><ul><li><p><code>NumFactor</code>和<code>PowerFactor</code>（幂函数因子）的<code>toPoly</code>方法很简单，直接转化为 <strong>只含有一个<code>Mono</code>的<code>Poly</code></strong> 即可。<strong>例如</strong>，因子<code>5</code>可以转化为一个只含有单项式<code>5*x**0</code>的多项式，因子<code>x**2</code>一个只含有单项式<code>1*x**2</code>的多项式。</p></li><li><p><code>Term</code>类的<code>toPoly()</code>方法是：将该类中含有的所有<code>Factor</code>的<code>Poly</code>形式（即<code>toPoly()</code>的结果）用<code>mulPoly()</code>方法乘起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Term.java</span></span><br><span class="line"><span class="keyword">public</span> Poly <span class="title function_">toPoly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义为1*x**0*y**0*z**0的Poly</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (Factor it : factors) &#123;</span><br><span class="line">        <span class="comment">//调用multPoly()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//调用negate()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> poly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        注意一个细节，因为项是有符号的，如果该项整体是负的，我们需要把<code>Poly</code>中所有的单项式的系数取反，这个取反操作我们是通过<code>Poly</code>类中定义的<code>negate()</code>方法实现的。</p></li><li><p><code>Expr</code>类的<code>toPoly()</code>方法是：将其含有的所有<code>Term</code>的<code>Poly</code>形式（即<code>toPoly()</code>的结果）用<code>addPoly()</code>方法加起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Expr.java</span></span><br><span class="line"><span class="keyword">public</span> Poly <span class="title function_">toPoly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义为0*x**0*y**0*z**0的Poly</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (Term it : terms) &#123;</span><br><span class="line">        <span class="comment">//调用addPoly()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> poly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样，我们就可以通过在每个类中定义的<code>toPoly()</code>方法<strong>自底向上</strong>地得到<strong>表达式的多项式形式</strong>。最后，我们再通过Poly中的<code>toString()</code>方法就可以获得最终展开后的结果。即先<code>expr.toPoly()</code>，再<code>poly.toString()</code>。</p><ul><li><em><strong>PS</strong></em>：一些输出时优化性能的小方法：<ul><li>如果单项式系数为<code>0</code>，则最终结果为<code>0</code>,</li><li>如果单项式系数为<code>1</code>，则可以省略系数，简化为$x^{n}$</li><li>如果单项式系数为<code>-1</code>，则可以省略系数，简化为$-x^{n}$</li><li>如果单项式x的指数为<code>0</code>，则最终结果只输出系数</li><li>如果单项式x的指数为<code>1</code>，则指数部分可以省略,简化为$ax$</li><li>如果单项式x的指数为<code>2</code>,则<code>x**2</code>可以化简为<code>x*x</code></li></ul></li></ul></li></ul><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><p>​        本次作业需要完成的任务为：在上一次作业的基础上，增加<strong>嵌套多层括号</strong>，新增<strong>三角函数因子</strong>、<strong>自定义函数因子</strong>，共三项任务。</p><p>【虽然看上去不多，但是小女子智商有限，迭代和debug的实际时间，比第一次作业“从无到有”编写代码的时间还长。只能说自己对于java的理解还是很浅显，尤其卡我的bug是——深拷贝、<code>HashMap</code>的重写<code>equal()</code>和<code>hashCode()</code>，以及一个一个疑惑“<em>为什么我的代码调试结果和运行结果不一样呢？</em>”】</p><ul><li><em><strong>PS</strong></em>：<ul><li>三角函数括号内部包含任意因子</li><li>自定义函数的函数表达式中不会调用其他函数</li><li>自定义函数只有<code>f</code>、<code>g</code>、<code>h</code>三个名字</li><li>更多要求详见教程</li></ul></li></ul><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://pic.imgdb.cn/item/6412a0cfebf10e5d53426238.png" alt="image-20230308131407133"></p><h3 id="代码架构-1"><a href="#代码架构-1" class="headerlink" title="代码架构"></a>代码架构</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expr   := Term   | Term   [+|-] Expr</span><br><span class="line">Term   := Factor | Factor [+|-] Term</span><br><span class="line">Factor := Expr   | NumFactor  | PowerFactor | SinFactor | CosFactor | FuncFactor</span><br></pre></td></tr></table></figure><p>​        通过分析表达式结构，我们发现可以给<code>Factor</code>新增两种类——三角函数因子，自定义函数因子：</p><h5 id="三角函数因子"><a href="#三角函数因子" class="headerlink" title="三角函数因子"></a>三角函数因子</h5><p>​        由于题目限制，我们可以只要新建<code>sinFactor</code>类和<code>cosFactor</code>类（其实也可以合并为一个类），类中有两个成员变量——<code>factor</code>(表示三角函数括号内的因子)，<code>exp</code>(表示三角函数的指数部分)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SinFactor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinFactor</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Factor factor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> exp;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CosFactor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CosFactor</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义函数因子"><a href="#自定义函数因子" class="headerlink" title="自定义函数因子"></a>自定义函数因子</h5><p>​        为记录并调用自定义函数，我新建了两个类——数据类<code>FuncFactor</code>、工具类<code>Definer</code>:</p><h6 id="FuncFactor"><a href="#FuncFactor" class="headerlink" title="FuncFactor"></a>FuncFactor</h6><p>​         <code>FuncFactor</code>类的成员变量有——<code>newFunc</code>（&#x2F;将函数实参带入形参位置后的字符串结果）和<code>expr</code>（将<code>newFunc</code>解析成表达式后的结果）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FuncFactor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncFactor</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String newFunc;</span><br><span class="line">    <span class="keyword">private</span> Expr expr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FuncFactor</span><span class="params">(String name, ArrayList&lt;Factor&gt; actualParas)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newFunc = Definer.callFunc(name, actualParas);</span><br><span class="line">        <span class="built_in">this</span>.expr = setExpr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expr <span class="title function_">setExpr</span><span class="params">()</span> &#123; <span class="comment">//类似重复一遍MainClass的解析表达式input</span></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Definer"><a href="#Definer" class="headerlink" title="Definer"></a>Definer</h6><p>​       <code>Definer</code>类主要处理自定义函数的<strong>定义</strong>和<strong>调用</strong>。该函数的成员和方法都是静态的，无需实例化对象，直接通过类名即可调用。</p><ul><li><p><code>Definer</code>类有两个私有静态成员——<code>funcMap</code>和<code>paraMap</code>，两者都是<code>HashMap</code>类型：</p><ul><li><p><code>funcMap</code>可以通过<strong>函数名</strong>（<code>f</code>&#x2F;<code>g</code>&#x2F;<code>h</code>）来获得<strong>函数的定义式</strong>；</p></li><li><p><code>paraMap</code>可以通过<strong>函数名</strong>来获得该<strong>函数的形参列表</strong>（<code>x</code>&#x2F;<code>y</code>&#x2F;<code>z</code>）。</p></li></ul></li><li><p><code>Definer</code>类还有两个函数——<code>addFunc()</code>和<code>callFunc()</code>：</p><ul><li><code>addFunc()</code>是在函数输入时使用，将终端输入的函数表达式传入该函数并进行解析，并将该函数的<strong>定义式</strong>和<strong>形参列表</strong>分别加入<code>funcMap</code>和<code>paraMap</code>；</li><li><code>callFunc()</code>是在函数调用时使用，传入的参量是函数名<code>name</code>和实参列表<code>acturalParas</code>，首先根据<code>name</code>获得<strong>函数定义式</strong>，再用<code>replaceAll</code>函数替换所有<strong>形参</strong>为<strong>实参</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Definer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,String&gt; funcMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; paraMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addFunc</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">//类似MainClass的预处理部分</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//统一把所有形参都改成u，v，w，防止后面debug的时候有xyz的扰乱</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//删除 = 前面的部分</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        funcMap.put(name.toString(), sb);</span><br><span class="line">        paraMap.put(name.toString(), paras);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">callFunc</span><span class="params">(String name,ArrayList&lt;Factor&gt; actualParas)</span> &#123;</span><br><span class="line">       <span class="comment">//replaceAll替换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流程分析-1"><a href="#流程分析-1" class="headerlink" title="流程分析"></a>流程分析</h4><p>​        迭代后程序依旧大致分为三个步骤——<em>预处理、表达式解析、计算优化输出</em>，下面进行具体分析与第一次作业的修改之处。</p><h5 id="预处理-1"><a href="#预处理-1" class="headerlink" title="预处理"></a>预处理</h5><p>​         为了简化之后的步骤我的预处理增加了三个部分——</p><ol><li>删除逗号后面无必要的+；</li><li>给每个逗号后面多加一个<code>(或,</code>（目的是在处理<code>praserFuncFactor()</code>的时候，让每个因子都先转化为<code>praserExpr</code>）;</li><li>给逗号后面紧接着的<code>-</code>前面加上<code>0</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Processer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Processer</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustSign</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//删掉*、(、，后面无必要的+</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//给，后面加上(或，</span></span><br><span class="line">        <span class="comment">//给（和，后面接着的-前面加0</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【令小女子“伤春悲秋”的是，本次作业的强测我挂了一个点，bug是没在预处理的时候把“，”后面无用的+删掉，导致出现了“空指针”异常，所以细心非常重要，望引以为戒~】</p><h5 id="表达式解析-1"><a href="#表达式解析-1" class="headerlink" title="表达式解析"></a>表达式解析</h5><p>​        表达式解析为了满足多层嵌套括号的要求，这里依旧选择<strong>递归下降算法</strong>，主要组成部分分别是——<code>Lexer</code>（词法分析器）和<code>Parser</code>（语法解析器）。</p><h6 id="Lexer-1"><a href="#Lexer-1" class="headerlink" title="Lexer"></a>Lexer</h6><p>​        在本次作业中语法单元的类型<code>TokenType</code>这一枚举类型新增<code>SIN</code>、<code>COS</code>、<code>F</code>、<code>G</code>、<code>H</code>、<code>COMMA（逗号）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TokenType</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    SIN, COS,</span><br><span class="line">    F, G, H,</span><br><span class="line">    COMMA,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        具体的<code>Lexer</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lexer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span> || c == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">            pos += <span class="number">4</span>;<span class="comment">//让pos停到sin和cos的因子的第一个字符</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;f&#x27;</span> || c == <span class="string">&#x27;g&#x27;</span> || c == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">            pos += <span class="number">1</span>;<span class="comment">//让pos停到f\g\h的第一个(上</span></span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            nextSwitch(c);</span><br><span class="line">            ++tokenNum;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextSwitch</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:<span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Parser-1"><a href="#Parser-1" class="headerlink" title="Parser"></a>Parser</h6><ul><li><p>​        为解析三角函数，我们在<code>parser</code>类中设置了一个<code>parserSinCosFactor()</code>方法，该方法在<code>parseFactor()</code>中被调用。</p><p>​        具体解析的逻辑是：先将<strong>三角函数括号内的因子</strong>进行解析（即在该方法中再调用<code>parseExpr()</code>方法），然后解析该<strong>三角函数的指数</strong>，最后将解析结果保存到一个<code>SinFactor</code>对象或者<code>CosFactor</code>对象中返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parser.java</span></span><br><span class="line"><span class="keyword">public</span> Factor <span class="title function_">parserSinCosFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">Factor</span> <span class="variable">inside</span> <span class="operator">=</span> parseExpr();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (type == TokenType.SIN) &#123; </span><br><span class="line">            <span class="comment">//这里因为TokenType已经多轮改变了，所以要额外用一个变量type存储下来</span></span><br><span class="line">            <span class="type">Factor</span> <span class="variable">sinFactor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SinFactor</span>(inside);</span><br><span class="line">            <span class="comment">//指数处理</span></span><br><span class="line">            <span class="keyword">return</span> sinFactor;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Factor</span> <span class="variable">cosFactor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CosFactor</span>(inside);</span><br><span class="line">            <span class="comment">//指数处理</span></span><br><span class="line">            <span class="keyword">return</span> cosFactor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>​        为解析自定义函数，我们在<code>parser</code>类中设置了一个<code>parserFuncFactor()</code>方法，该方法在<code>parseFactor()</code>中被调用。</p><p>​        具体解析的逻辑是：先按照函数的<code>name</code>得到它形参的个数，然后解析该个数的<strong>实参</strong>（即在该方法中再调用<code>parseFactor()</code>方法），然后讲这个<code>FuncFactor</code>再次解析成<code>Factor</code>类型，最后将解析结果保存到一个<code>newFuncFactor</code>对象返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parser.java</span></span><br><span class="line"><span class="keyword">public</span> Factor <span class="title function_">parserFuncFactor</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= (Definer.getParaMap().get(name).size()); i++) &#123;</span><br><span class="line">            actualParas.add(parseFactor());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FuncFactor</span> <span class="variable">funcFactor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FuncFactor</span>(name,actualParas);</span><br><span class="line">        <span class="type">Factor</span> <span class="variable">newFuncFactor</span> <span class="operator">=</span> funcFactor.getExpr();</span><br><span class="line">        <span class="comment">//若有指数，读入分析</span></span><br><span class="line">        <span class="keyword">return</span> newFuncFactor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>PS</strong></em>：在这里回顾我们可以发现我在解析<code>sin</code>、<code>cos</code>、<code>f|g|h</code>的括号因子的时候，前者用的<code>parserExpr()</code>，后者用的<code>parserFactor()</code>，这里实际上是一套配套的过程：</p><ul><li>对于<code>sin</code>、<code>cos</code>的处理，我<code>Lexer</code>解析时<code>pos+=4;</code>，因此使用<code>parserExpr()</code>；</li><li>对于<code>f|g|h</code>的处理，我<code>Lexer</code>解析时<code>pos+=1;</code>，<code>Processer</code>中给<code>,</code>后面加上<code>(</code>，因此使用<code>parserFactor()</code>。</li></ul><p>【没有固定的写法，所以可以根据个人的架构来选择构造哟~】</p></li></ul><h5 id="计算优化输出-1"><a href="#计算优化输出-1" class="headerlink" title="计算优化输出"></a>计算优化输出</h5><p>​        本次作业的计算单元通过分析可以归纳成式子——$$ax^n\prod_isin(Factor_i)\prod_jcos(Factor_j)$$</p><p>【这里小女子“被迫”花费了大量时间，尽是一把辛酸泪~】</p><h6 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h6><p>​       <code>Unit</code>类就是原来的<code>Mono</code>类，改动最大的地方是——</p><ol><li>建立<code>HashMap&lt;Poly,Integer&gt;</code>的<code>sinMap\cosMap</code>；因为<code>key</code>是自定义类，因此<code>hashCode()</code>和<code>equals()</code>要按照自己的要求改动；</li><li>为了后续的深拷贝，建立函数<code>public Unit cloneInSerializable()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unit</span>  <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Poly,Integer&gt; sinMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Poly,Integer&gt; cosMap;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">public</span> Unit <span class="title function_">mulUnit</span><span class="params">(Unit iunit)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.sinMap.size() != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cosMap.size() != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iunit.sinMap.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iunit.cosMap.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Unit</span>(<span class="built_in">this</span>.coe.multiply(iunit.coe),</span><br><span class="line">                <span class="built_in">this</span>.expX + iunit.expX,</span><br><span class="line">                <span class="built_in">this</span>.expY + iunit.expY,</span><br><span class="line">                <span class="built_in">this</span>.expZ + iunit.expZ,</span><br><span class="line">                sinMapCopy, cosMapCopy);<span class="comment">//既能得到值，又不会改变原来Unit的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletSinCos</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//把 sin(factor)**0 和 cos(factor)**0 这些无用的HashMap元素删除，方便后续转化为字符串的时候可以简化部分运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123; <span class="comment">/*模板*/</span>   &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">/*模板，但是不能加coe*/</span>  &#125;</span><br><span class="line">    <span class="keyword">public</span> Unit <span class="title function_">cloneInSerializable</span><span class="params">()</span> &#123; <span class="comment">/*深拷贝模板*/</span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Poly-1"><a href="#Poly-1" class="headerlink" title="Poly"></a>Poly</h6><p>​       <code>Poly</code>类和<code>Unit</code>类一样，改动最大的地方是——</p><ol><li>建立<code>HashMap&lt;Unit,BigInteger&gt;</code>的<code>unitMap</code>；因为<code>key</code>是自定义类，因此<code>hashCode()</code>和<code>equals()</code>要按照自己的要求改动；</li><li>为了后续的深拷贝，建立函数<code>public Poly cloneInSerializable()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Poly.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poly</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Unit&gt; units;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Unit,BigInteger&gt; unitMap;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="comment">/*模板*/</span> &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">/*模板，但是不能加unitMap*/</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> Poly <span class="title function_">cloneInSerializable</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">//toString 里面所有的必须深拷贝</span></span><br><span class="line">       <span class="comment">//...&#123;</span></span><br><span class="line">                    sb = printXyz(sb,iunit);</span><br><span class="line">                    sb = printSin(sb,iunit);</span><br><span class="line">                    sb = printCos(sb,iunit);</span><br><span class="line">       <span class="comment">//    &#125;...      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">printXyz</span><span class="params">(StringBuilder sb,Unit iunit)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">printSin</span><span class="params">(StringBuilder sb,Unit iunit)</span> &#123; <span class="comment">/*sin*/</span></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">if</span> (iunit.getSinMap().size() != <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator&lt;Poly&gt; iterator = iunit.getSinMap().keySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//sin((0))</span></span><br><span class="line">                  <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//给sin()里面的因子再加上一层()</span></span><br><span class="line">                  <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//删除最后无用的*</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">printCos</span><span class="params">(StringBuilder sb,Unit iunit)</span> &#123; <span class="comment">/*cos*/</span>  &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><em><strong>PS</strong></em>：本次大致可以优化性能的三个点：</p><ul><li>合并所有的同类型；</li><li>转化<code>sin(0)=0</code>、<code>cos(0)=1</code>；</li><li>化简<code>sin\cos</code>的因子（类似再同样的步骤进行一次小型<code>MainClass</code>），并判断删除无必要的括号，例如：<code>sin((-1))=sin(-1)</code>.</li></ul><p>【实际上，三角函数还可以用一些公式化简，例如：<code>sin(x)**2 + cos(x)**2 = 1</code>、二倍角公式、积化和差公式等等，但是具体实现会拥有更多难度，小女子由于在debug上浪费了很多时间，所以并不曾有机会尝试化简~  但经过“走访人世”，也听说了有很多同学尝试失败了，因此等待大牛留言<del>浇浇</del>】</p></li></ul><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><p>  本次作业需要完成的任务为：在上一次作业的基础上，增加<strong>求导因子</strong>，令<strong>自定义函数可以调用其他已经定义了的函数</strong>，共两项任务。</p><ul><li><em><strong>PS</strong></em>：<ul><li>求导仅仅包括<code>dx</code>、<code>dy</code>、<code>dz</code>；</li><li>更多要求详见教程</li></ul></li></ul><h3 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://pic.imgdb.cn/item/6412a0ffebf10e5d5342e2ab.png" alt="image-20230314185329891"></p><h3 id="代码架构-2"><a href="#代码架构-2" class="headerlink" title="代码架构"></a>代码架构</h3><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expr   := Term   | Term   [+|-] Expr</span><br><span class="line">Term   := Factor | Factor [+|-] Term</span><br><span class="line">Factor := </span><br><span class="line">    Expr   | Term | NumFactor | PowerFactor | SinFactor | CosFactor | FuncFactor</span><br></pre></td></tr></table></figure><p>​        通过分析表达式结构，我们发现可以给<code>Factor</code>新增一种类——<code>Term</code>因子：</p><h5 id="Term因子"><a href="#Term因子" class="headerlink" title="Term因子"></a>Term因子</h5><p>​       只要把Factor接口接到Term上即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Term.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Term</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>​        值得注意的是，在本次迭代代码的过程中，我使用了两种深拷贝的方式——<strong>序列化</strong>、**重写<code>clone()</code>**：</p><h6 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h6><p>​        使用序列化进行深拷贝的有两个类——<code>Poly</code>、<code>Unit</code>，使用序列化只要给该类加上接口<code>Serializable</code>，并编写函数<code>cloneInSerializable()</code>，以<code>Unit</code>类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unit</span>  <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">public</span> Unit <span class="title function_">cloneInSerializable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Unit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Serializable object</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Unserializable object</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line"></span><br><span class="line">            unit = (Unit) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="重写clone"><a href="#重写clone" class="headerlink" title="重写clone()"></a>重写<code>clone()</code></h6><p>​       使用重写<code>clone()</code>进行深拷贝的有七个类——所有使用了<code>Factor</code>接口的类，使用重写<code>clone()</code>只要所有涉及定义了变量的类都加上重写函数<code>clone()</code>，以<code>Expr</code>、<code>Term</code>、<code>SinFactor</code>类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Expr.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Expr</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; terms.size(); i++) &#123;</span><br><span class="line">            expr.addTerm((Term) terms.get(i).clone());</span><br><span class="line">        &#125;</span><br><span class="line">        expr.exp = <span class="built_in">this</span>.exp;</span><br><span class="line">        <span class="keyword">return</span> expr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Term.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Term</span> <span class="variable">term</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Term</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; factors.size(); i++) &#123;</span><br><span class="line">            term.addFactor(factors.get(i).clone());</span><br><span class="line">        &#125;</span><br><span class="line">        term.sign = <span class="built_in">this</span>.sign;</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SinFactor.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SinFactor</span>(factor.clone(), exp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="流程分析-2"><a href="#流程分析-2" class="headerlink" title="流程分析"></a>流程分析</h4><p>​        迭代后程序依旧大致分为三个步骤——<em>预处理、表达式解析、计算优化输出</em>，下面进行具体分析与第二次作业的修改之处。</p><h5 id="预处理-2"><a href="#预处理-2" class="headerlink" title="预处理"></a>预处理</h5><p>​         本次我在预处理部分主要修改了两个地方——<code>MainClass</code>与<code>Definer</code>类：</p><h6 id="MainClass"><a href="#MainClass" class="headerlink" title="MainClass"></a>MainClass</h6><p>​         将语句定义到一个静态函数中<code>public static Parser parserString(String str)</code>，方便在处理自定义函数定义部分来重复调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainClass.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Parser <span class="title function_">parserString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Processer</span> <span class="variable">processer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Processer</span>(str);</span><br><span class="line">        processer.delBlank();<span class="comment">//删掉空白符</span></span><br><span class="line">        processer.delPlusMinus();<span class="comment">//删掉多余重复的加减号，并删除首位的加号</span></span><br><span class="line">        processer.adjustSign();<span class="comment">//杂七杂八的处理</span></span><br><span class="line"></span><br><span class="line">        Lexer lexer;</span><br><span class="line">        <span class="keyword">if</span> (processer.nowInput().charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            lexer = <span class="keyword">new</span> <span class="title class_">Lexer</span>(<span class="string">&quot;0&quot;</span> + processer.nowInput());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lexer = <span class="keyword">new</span> <span class="title class_">Lexer</span>(processer.nowInput());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Parser</span>(lexer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="Definer-1"><a href="#Definer-1" class="headerlink" title="Definer"></a>Definer</h6><p>​        这一部分，我将处理自定义函数的定义式部分也当成了一次小型的表达式解析，来达到可以解决<strong>自定义函数中调用其他函数</strong>的问题：</p><p>【但是由于小女子自己代码架构的问题，这个部分被我自己埋下一个潜藏的bug，特导致强测又挂了一个点~  哭唧唧~  后续会有跟具体的分析】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Definer</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addFunc</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="type">Processer</span> <span class="variable">processer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Processer</span>(input);</span><br><span class="line">        processer.delBlank();<span class="comment">//删掉空白符【注意仅仅进行去空格，不要其他预处理了】</span></span><br><span class="line">        <span class="comment">//截取=后面的表达式</span></span><br><span class="line">        sb = putInFunc(sb);</span><br><span class="line">        <span class="comment">//参数替换成u，v，w</span></span><br><span class="line">        funcMap.put(name.toString(), sb);</span><br><span class="line">        paraMap.put(name.toString(), paras);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">putInFunc</span><span class="params">(String sb)</span> &#123;</span><br><span class="line">        <span class="comment">//先将自定义函数表达式求导后再代入实参</span></span><br><span class="line">        <span class="type">Parser</span> <span class="variable">parser</span> <span class="operator">=</span> MainClass.parserString(sb);</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> parser.parseExpr();</span><br><span class="line">        <span class="type">Poly</span> <span class="variable">poly</span> <span class="operator">=</span> expr.toPoly();</span><br><span class="line">        <span class="keyword">return</span> poly.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="表达式解析-2"><a href="#表达式解析-2" class="headerlink" title="表达式解析"></a>表达式解析</h5><p>​        表达式解析为了满足多层嵌套括号的要求，这里依旧选择<strong>递归下降算法</strong>，主要组成部分分别是——<code>Lexer</code>（词法分析器）和<code>Parser</code>（语法解析器）。</p><h6 id="Lexer-2"><a href="#Lexer-2" class="headerlink" title="Lexer"></a>Lexer</h6><p>​        在本次作业中语法单元的类型<code>TokenType</code>这一枚举类型新增<code>DX</code>、<code>DY</code>、<code>DZ</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TokenType</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    DX, DY, DZ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        具体的<code>Lexer</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lexer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.charAt(pos + <span class="number">1</span>) == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.charAt(pos + <span class="number">1</span>) == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            pos += <span class="number">3</span>;<span class="comment">//注意这里模仿f，g，h，让pos停留在(上面</span></span><br><span class="line">            ++tokenNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Parser-2"><a href="#Parser-2" class="headerlink" title="Parser"></a>Parser</h6><ul><li><p>​        为解析求导因子，我们在<code>parser</code>类中设置了一个<code>parserDerFactor()</code>方法，该方法在<code>parseFactor()</code>中被调用。</p><p>​        具体解析的逻辑是：先将<strong>求导因子括号内的表达式</strong>进行解析（即在该方法中再调用<code>parseExpr()</code>方法），然后解析该<strong>求导因子的指数</strong>，最后将解析结果保存到一个<code>Expr</code>对象返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parser.java</span></span><br><span class="line"><span class="keyword">public</span> Factor <span class="title function_">parserDerFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        lexer.next();</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">inside</span> <span class="operator">=</span> parseExpr();<span class="comment">//注意按照表达式解析</span></span><br><span class="line">        lexer.next();</span><br><span class="line">        <span class="keyword">if</span> (type == TokenType.DX) &#123;</span><br><span class="line">            <span class="type">Factor</span> <span class="variable">dxFactor</span> <span class="operator">=</span> inside.expand().derive(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="type">Expr</span> <span class="variable">dxExpr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Expr</span>();</span><br><span class="line">            dxExpr.addTerm((Term) dxFactor);</span><br><span class="line">            <span class="comment">//指数处理</span></span><br><span class="line">            <span class="keyword">return</span> dxExpr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">//....</span></span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure></li><li><p>​        通过观察上述的<code>parserDerFactor()</code>方法，我们观察到最新增加并迭代的方法是<code>expand()</code>、<code>derive(String)</code>，以下具体阐释这两个函数：</p><ul><li><p><code>expand()</code></p><p>只有两个类中定义了<code>expand()</code>函数——<code>Expr</code>、<code>Term</code>：</p><p><em><strong>PS</strong></em>：注意<code>other</code>实例也是有符号的！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Expr.java</span></span><br><span class="line"><span class="keyword">public</span> Factor <span class="title function_">expand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; terms.size(); i++) &#123;</span><br><span class="line">            expr = Expr.mergeExpr(expr, (Expr) terms.get(i).expand());</span><br><span class="line">            <span class="comment">//mergeExpr表示合并两个expr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Term.java</span></span><br><span class="line"><span class="keyword">public</span> Factor <span class="title function_">expand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...递归实现去括号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; factors.size(); i++) &#123;</span><br><span class="line">            <span class="type">Factor</span> <span class="variable">factor</span> <span class="operator">=</span> factors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (factor <span class="keyword">instanceof</span> Expr) &#123;</span><br><span class="line">                hasExprFactor = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// ...other为其余因子组成的项</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; factors.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                        other.addFactor(factors.get(j).clone());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">for</span> (Term t : e.getTerms()) &#123;</span><br><span class="line">                    expr.addTerm(Term.mergeTerm(other, t));<span class="comment">//实现乘法分配律</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasExprFactor) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>derive(String)</code></p><p>所有<code>Factor</code>接口的类，都拥有<code>derive(String)</code>函数，以<code>Expr</code>、<code>Term</code>、<code>CosFactor</code>、<code>PowerFactor</code>类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Expr.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">derive</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; terms.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// ps:注意term求导会变成expr</span></span><br><span class="line">            expr = Expr.mergeExpr(expr, (Expr) terms.get(i).derive(name));</span><br><span class="line">        &#125;</span><br><span class="line">        term.addFactor(expr);</span><br><span class="line">        <span class="comment">// ...返回Term类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Term.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">derive</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; factors.size(); i++) &#123;</span><br><span class="line">            <span class="type">Term</span> <span class="variable">t</span> <span class="operator">=</span> (Term) factors.get(i).derive(name);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; factors.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    <span class="comment">// ps:乘法法则 </span></span><br><span class="line">                    t.addFactor(factors.get(j).clone());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...符号处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...返回Expr类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CosFactor.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">derive</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        term.addFactor(toSin());<span class="comment">//toSin()如函数名字所表示，转为sinFactor</span></span><br><span class="line">        term.addFactor(<span class="keyword">new</span> <span class="title class_">NumFactor</span>(BigInteger.valueOf(-<span class="number">1</span>), <span class="number">1</span>));</span><br><span class="line">        term = Term.mergeTerm(term, (Term) factor.derive(name));</span><br><span class="line">        <span class="comment">// ...返回Term类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PowerFactor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">derive</span><span class="params">(String c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (base.equals(c)) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...返回Term类型</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><em><strong>PS</strong></em>：这里的逻辑操作，主要是借鉴了实验课的<code>exam2</code>中对于求导的处理方式。【实验课真的很重要哇~  疯狂爱上实验课提出的思路~  好好听讲学习中】</p></li></ul><h5 id="计算优化输出-2"><a href="#计算优化输出-2" class="headerlink" title="计算优化输出"></a>计算优化输出</h5><p>​      本次作业的计算优化部分我没有任何改动。【好的架构真的很重要哇~】</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​       最终版代码复杂度如下：</p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>CosFactor</td><td>1.0</td><td>1.0</td><td>7.0</td></tr><tr><td>Definer</td><td>2.5</td><td>5.0</td><td>10.0</td></tr><tr><td>Expr</td><td>1.6</td><td>3.0</td><td>16.0</td></tr><tr><td>FuncFactor</td><td>1.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Lexer</td><td><strong>5.166666666666667</strong></td><td>13.0</td><td><strong>31.0</strong></td></tr><tr><td>MainClass</td><td>2.0</td><td>2.0</td><td>4.0</td></tr><tr><td>NumFactor</td><td>1.0</td><td>1.0</td><td>6.0</td></tr><tr><td>Parser</td><td><strong>5.142857142857143</strong></td><td>12.0</td><td><strong>36.0</strong></td></tr><tr><td>Poly</td><td><strong>4.285714285714286</strong></td><td>12.0</td><td><strong>60.0</strong></td></tr><tr><td>PowerFactor</td><td>1.6666666666666667</td><td>4.0</td><td>10.0</td></tr><tr><td>Processer</td><td><strong>4.2</strong></td><td>9.0</td><td>21.0</td></tr><tr><td>SinFactor</td><td>1.0</td><td>1.0</td><td>7.0</td></tr><tr><td>Term</td><td>2.6666666666666665</td><td>7.0</td><td><strong>32.0</strong></td></tr><tr><td>TokenType</td><td></td><td></td><td>0.0</td></tr><tr><td>Unit</td><td>2.5384615384615383</td><td>11.0</td><td><strong>33.0</strong></td></tr><tr><td><strong>Total</strong></td><td></td><td></td><td>276.0</td></tr><tr><td><strong>Average</strong></td><td>2.7058823529411766</td><td>5.857142857142857</td><td>18.4</td></tr></tbody></table><p>​       其中有几个方法的复杂度格外高，是不足之处，也是有待优化之处：</p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Lexer.next()</td><td>23.0</td><td>2.0</td><td>12.0</td><td>17.0</td></tr><tr><td>Parser.parseFactor()</td><td>20.0</td><td>6.0</td><td>17.0</td><td>18.0</td></tr><tr><td>Poly.printCos(StringBuilder, Unit)</td><td>20.0</td><td>4.0</td><td>14.0</td><td>14.0</td></tr><tr><td>Poly.toString()</td><td>24.0</td><td>3.0</td><td>17.0</td><td>18.0</td></tr><tr><td>Processer.adjustSign()</td><td>14.0</td><td>3.0</td><td>10.0</td><td>13.0</td></tr><tr><td>Processer.delPlusMinus()</td><td>16.0</td><td>3.0</td><td>6.0</td><td>10.0</td></tr><tr><td>Term.expand()</td><td>15.0</td><td>4.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Unit.mulUnit(Unit)</td><td>20.0</td><td>1.0</td><td>11.0</td><td>11.0</td></tr><tr><td><strong>Total</strong></td><td>320.0</td><td>138.0</td><td>297.0</td><td>337.0</td></tr><tr><td><strong>Average</strong></td><td>3.1372549019607843</td><td>1.3529411764705883</td><td>2.911764705882353</td><td>3.303921568627451</td></tr></tbody></table><h2 id="强测互测分析"><a href="#强测互测分析" class="headerlink" title="强测互测分析"></a>强测互测分析</h2><h3 id="强测"><a href="#强测" class="headerlink" title="强测"></a>强测</h3><p>​       第一单元我强测一个挂了两个点，分别在第二次作业和第三次作业各一次。其中，第二次作业的bug是因为预处理中少了一个去除加号的判断条件，与代码架构关系不大，这里不具体分析。</p><p>​       但是，第三次作业的bug与代码架构有千丝万缕的联系，这里具体分析一下：</p><p>​       在我的代码架构中，处理<strong>自定义函数</strong>的时候，为了准确读取分析好各个<strong>实参</strong>，我在所有的<strong>逗号</strong>后面加了一个<code>(</code>，以便于在读取实参的时候，能够强制转化成<code>Expr</code>类型，才能使我的代码正确处理<strong>实参中外嵌乘方</strong>的形式。</p><p>​       而第三次作业中，我的问题便出现在这里，我的错误代码在读入处理自定义函数定义式的时候，进行了两个遍预处理，于是导致自己的所有的<strong>逗号</strong>后面加了两个<code>(</code>，导致<code>parserFunctor()</code>中读取实参的时候无法准确确定实参的结尾，故而导致的bug。</p><p>​       实际上，这个bug可以看做是一种由于偷懒【唉声叹气ing，又又又又又又被懒惰偷袭了~】导致的双层预处理错误，但是我仔细思考之后，认为这可以看做我代码架构的问题：在解析实参的时候用的<code>parserFactor()</code>，而不是<code>parserExpr()</code>，如果直接按照表达式处理，虽然会导致我要改动<code>parserExpr()</code>方法中的部分逻辑结构，但可以避免我上述所犯的错误。</p><h3 id="互测"><a href="#互测" class="headerlink" title="互测"></a>互测</h3><p>​       评测机的重要性！！在互测的时候实际上也是在同步进行OS课程的实验任务，因此hack别人的时间是十分有限的，如果一个个仔细研究互测成员的代码，时间会明显不足够。因此，这里我推荐的hack别人的方法是：先用评测机确定大致有问题的代码方向，然后带有指向性地阅读成员代码，来寻找bug的原理，据此编写待提交的hack数据。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​       第一单元的学习总的来说还是相对比较难的，难度主要在从无到有的<strong>创造感</strong>、<strong>迷茫感</strong>与<strong>突破性</strong>。同时，通过各项数据的对比，我们也清晰地了解到<strong>OO先导课</strong>的重要性和不可取代性。参考借鉴<strong>往届学长学姐的Blog</strong>将会是一项十分有用的助力。</p>]]></content>
      
      
      <categories>
          
          <category> 养德（学习） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>铃•序曲</title>
      <link href="/2023/03/01/%E9%93%83%E2%80%A2%E5%BA%8F%E6%9B%B2/"/>
      <url>/2023/03/01/%E9%93%83%E2%80%A2%E5%BA%8F%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<ul><li><p>我建立博客的初心——<strong>听铃，聆听，浮生清欢</strong></p></li><li><p>博客将会不定期更新一些细碎的内容，包括但不限于：学习心得、生活感悟</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 修身（生活） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小羊咩咩~ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
