<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>BUAA-OS-lab4 | YannaのBlog</title><meta name="author" content="YannaZhang 张杨"><meta name="copyright" content="YannaZhang 张杨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab4实验报告 思考题 Thinking 4.1  思考并回答下面的问题：  内核在保存现场的时候是如何避免破坏通用寄存器的？ 系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall留下的信息吗？ 我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样的参数的？ 内核处理系统调用的过程对 Trapframe 做了哪些更改">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-lab4">
<meta property="og:url" content="http://example.com/2023/05/15/BUAA-OS-4/index.html">
<meta property="og:site_name" content="YannaのBlog">
<meta property="og:description" content="Lab4实验报告 思考题 Thinking 4.1  思考并回答下面的问题：  内核在保存现场的时候是如何避免破坏通用寄存器的？ 系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall留下的信息吗？ 我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样的参数的？ 内核处理系统调用的过程对 Trapframe 做了哪些更改">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/series1/7.png">
<meta property="article:published_time" content="2023-05-15T13:03:24.000Z">
<meta property="article:modified_time" content="2023-06-19T08:55:37.133Z">
<meta property="article:author" content="YannaZhang 张杨">
<meta property="article:tag" content="BUAA-OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/series1/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/15/BUAA-OS-4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: YannaZhang 张杨","link":"链接: ","source":"来源: YannaのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-lab4',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-19 16:55:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/archive_img.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 扉页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 光阴簿</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 签轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 编类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 籍</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 曲籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-commenting"></i><span> 留音笺</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 卿</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 予</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="YannaのBlog"><span class="site-name">YannaのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 扉页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 光阴簿</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 签轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 编类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 籍</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 曲籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-commenting"></i><span> 留音笺</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 卿</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 予</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-lab4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T13:03:24.000Z" title="发表于 2023-05-15 21:03:24">2023-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-19T08:55:37.133Z" title="更新于 2023-06-19 16:55:37">2023-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%BB%E5%BE%B7%EF%BC%88%E5%AD%A6%E4%B9%A0%EF%BC%89/">养德（学习）</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-lab4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="lab4实验报告">Lab4实验报告</h1>
<h2 id="思考题">思考题</h2>
<h3 id="thinking-4-1">Thinking 4.1</h3>
<blockquote>
<p>思考并回答下面的问题：</p>
<ul>
<li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li>
<li>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 <code>msyscall</code>留下的信息吗？</li>
<li>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 <code>msyscall</code> 时同样的参数的？</li>
<li>内核处理系统调用的过程对 <code>Trapframe</code> 做了哪些更改？这种修改对应的用户态的变化是什么？</li>
</ul>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p>在 <code>SAVE_ALL</code> 中：</p>
<p>先 <code>move k0,sp</code>，先把通用寄存器的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">sp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span></span></span></span> 复制到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>k</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\$k0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">0</span></span></span></span> ；</p>
<p>再 <code>sw k0,TF_REG29(sp)、sw $2,TF_REG2(sp)</code>：保存现场需要使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>v</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\$v0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span></span></span></span> 作为协寄存器到内存的中转寄存器，写到内存时需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">sp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span></span></span></span> ，所以在正式保存协寄存器和通用寄存器前先保存这两个寄存器。</p>
</li>
<li>
<p>可以。</p>
<p>从用户函数 <code>syscall_*()</code> 到内核函数 <code>sys_*()</code> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>a</mi><mn>1</mn><mo>−</mo><mi mathvariant="normal">$</mi><mi>a</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\$a1-\$a3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.08333em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">3</span></span></span></span> 未改变，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>a</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\$a0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">0</span></span></span></span> 在<code>handle_sys()</code> 的时候被修改为内核函数的地址，但在内核函数 <code>sys_*()</code> 仅为占位符，不会被用到。同时，在内核态中可能使用这些寄存器进行一些操作计算，此时寄存器原有值被改变，因此再次以这些参数调用其他函数时需要重新以sp为基地址，按相应偏移从用户栈中取用这四个寄存器值。</p>
<p>总之，一般情况下，还是从栈中取得这些参数更加保险。</p>
</li>
<li>
<p>用户调用时的参数：</p>
<ol>
<li>
<p>用户进程的寄存器现场（保存在了内核栈的？？TF_4-TF_7？？）的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>a</mi><mn>1</mn><mo>−</mo><mi mathvariant="normal">$</mi><mi>a</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\$a1-\$a3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.08333em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">3</span></span></span></span> ；</p>
</li>
<li>
<p>用户栈(栈指针为<strong>用户现场</strong>的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">sp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span></span></span></span> )的参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>a</mi><mn>4</mn><mtext>、</mtext><mi mathvariant="normal">$</mi><mi>a</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\$a4 、\$a5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">4</span><span class="mord cjk_fallback">、</span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">5</span></span></span></span>；</p>
</li>
</ol>
<p>把上面两部分参数分别拷贝至<strong>内核现场</strong>寄存器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>a</mi><mn>1</mn><mo>−</mo><mi mathvariant="normal">$</mi><mi>a</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\$a1-\$a3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.08333em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault">a</span><span class="mord">3</span></span></span></span> 和内核栈。</p>
</li>
<li>
<p>第一，将栈中存储的EPC寄存器值增加4，这是因为系统调用后，将会返回下一条指令，而用户程序会保证系统调用操作不在延迟槽内，所以直接加4得到下一条指令的地址；</p>
<p>第二，将返回值存入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">$</mi><mi>v</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\$v0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span></span></span></span> 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-2">Thinking 4.2</h3>
<blockquote>
<p>思考 <code>envid2env</code> 函数: 为什么 <code>envid2env</code> 中需要判断 <code>e-&gt;env_id != envid</code> 的情况？如果没有这步判断会发生什么情况？</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p>在我们生成envid时，<strong>后十位</strong>为了方便从envs数组中直接取出Env，可能会有所重叠，</p>
<p>envid的独一性<strong>取决于mkenvid里不断增长的 <code>i</code></strong> ，所以如果不判断envid是否相同，会取到错误的或者本该被销毁的进程控制块。</p>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-3">Thinking 4.3</h3>
<blockquote>
<p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 <em>kern/env.c</em> 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 <code>0</code>，请结合系统调用和 <em>IPC</em> 部分的实现与<code>envid2env()</code> 函数的行为进行解释。</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p>我们可以看到该函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(struct Env *e)</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">u_int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>++i</code> 保证一定不会为0；<code>envid2env()</code>的envid为0时返回curenv；</p>
<ul>
<li>由于 <code>curenv</code> 为内核态的变量，用户态不能获取 <code>curenv</code> 的 <code>envid</code>，所以用 0 代表 <code>curenv-&gt;envid</code>；</li>
<li>目的是方便用户进程调用 <code>syscall_*()</code> 时把当前进程的 <code>envid</code> 作为参数传给内核函数，即方便用户态在内核变量不可见的情况下调用内核接口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-4">Thinking 4.4</h3>
<blockquote>
<p>关于 <code>fork</code> 函数的两个返回值，下面说法正确的是：<br>
A、 <code>fork</code> 在父进程中被调用两次，产生两个返回值<br>
B、 <code>fork</code> 在两个进程中分别被调用一次，产生两个不同的返回值<br>
C、 <code>fork</code> 只在父进程中被调用了一次，在两个进程中各产生一个返回值<br>
D、 <code>fork</code> 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p>
</blockquote>
<ul>
<li>解：
<ul>
<li>正确答案是<strong>C</strong></li>
</ul>
</li>
</ul>
<h3 id="thinking-4-5">Thinking 4.5</h3>
<blockquote>
<p>我们并不应该对所有的用户空间页都使用 <code>duppage</code> 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 <em>kern/env.c</em> 中 <code>env_init</code> 函数进行的页面映射、 <em>include/mmu.h</em> 里的内存布局图以及本章的后续描述进行思考。</p>
</blockquote>
<ul>
<li>解：
<ul>
<li>
<p>在 0 ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>S</mi><mi>T</mi><mi>A</mi><mi>C</mi><mi>K</mi><mi>T</mi><mi>O</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">USTACKTOP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 范围的内存需要使用 <code>duppage</code> 进行映射;</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>S</mi><mi>T</mi><mi>A</mi><mi>C</mi><mi>K</mi><mi>T</mi><mi>O</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">USTACKTOP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>T</mi><mi>O</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">UTOP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 之间的 <strong>user exception stack</strong> 是用来进行页写入异常的，不会在处理COW异常时调用 <code>fork()</code> ,所以 user exception stack 这一页不需要共享；</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>S</mi><mi>T</mi><mi>A</mi><mi>C</mi><mi>K</mi><mi>T</mi><mi>O</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">USTACKTOP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>T</mi><mi>O</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">UTOP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 之间的 <strong>invalid memory</strong> 是为处理页写入异常时做缓冲区用的，所以同理也不需要共享；</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>T</mi><mi>O</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">UTOP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>以上页面的<strong>内存与页表</strong>是所有进程共享的，且用户进程无权限访问，不需要做父子进程间的duppage；</p>
<ul>
<li>其上范围的内存要么<strong>属于内核</strong>，要么是所有用户进程<strong>共享的空间</strong>，用户模式下只可以读取。除只读、共享的页面外都需要设置 <code>PTE_COW</code> 进行保护。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-6">Thinking 4.6</h3>
<blockquote>
<p>在遍历地址空间存取页表项时你需要使用到 <code>vpd</code> 和 <code>vpt</code> 这两个指针，请参考 <em>user/include/lib.h</em> 中的相关定义，思考并回答这几个问题：</p>
<ul>
<li>vpt 和 vpd 的作用是什么？怎样使用它们？</li>
<li>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li>
<li>它们是如何体现自映射设计的？</li>
<li>进程能够通过这种方式来修改自己的页表项吗？</li>
</ul>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p>作用：在用户态下通过访问进程自己的物理内存获取用户页的页目录项页表项的 <code>perm</code>，用于 <code>duppage</code> 根据不同的 <code>perm</code> 类型在父子进程间执行不同的物理页映射；</p>
</li>
<li>
<p>使用：</p>
<ul>
<li>vpd是<strong>页目录首地址</strong>，以vpd为基地址，加上页目录项偏移数即可<strong>指向va对应页目录项</strong>，即<code>(*vpd) + (va &gt;&gt; 22)</code> 或 <code>vpd[va &gt;&gt; 22]</code>；</li>
<li>vpt是<strong>页表首地址</strong>，以vpt为基地址，加上页表项偏移数即可<strong>指向va对应的页表项</strong>，即<code>(*vpt) + (va &gt;&gt; 12)</code> 或 <code>vpt[va &gt;&gt; 12]</code> 即 <code>vpt[VPN(va)]</code>；</li>
</ul>
</li>
<li>
<p>自映射设计体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br></pre></td></tr></table></figure>
<p>vpd的地址在UVPT和UVPT + PDMAP之间，说明将页目录映射到了某一页表位置(即实现了自映射);</p>
</li>
<li>
<p>不能。该区域对用户<strong>只读不写</strong>，若想要增添页表项，需要陷入内核进行操作。</p>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-7">Thinking 4.7</h3>
<blockquote>
<p>在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 <code>Trapframe</code>运行现场的过程，请思考并回答这几个问题：</p>
<ul>
<li>这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</li>
<li>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li>
</ul>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p>当出现COW异常时，需要使用用户态的系统调用发生中断，即中断重入；</p>
</li>
<li>
<p>由于处理COW异常时调用的 <code>handle_mod()</code> 函数把epc改为用户态的异常处理函数 <code>env_user_tlb_mod_entry </code> ，退出内核中断后跳转到epc所在的用户态的异常处理函数。</p>
<p>由于用户态把异常处理完毕后仍然在用户态恢复现场，所以此时要把内核保存的现场保存在用户空间的用户异常栈。</p>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-8">Thinking 4.8</h3>
<blockquote>
<p>在用户态处理页写入异常，相比于在内核态处理有什么优势？</p>
</blockquote>
<ul>
<li>解：
<ul>
<li>解放内核，不用内核执行大量的页面拷贝工作；</li>
<li>内核态处理失误产生的影响较大，可能会使得操作系统崩溃；</li>
<li>用户状态下不能得到一些在内核状态才有的权限，避免改变不必要的内存空间；</li>
<li>同时微内核的模式下，用户态进行新页面的分配映射也更加灵活方便。</li>
</ul>
</li>
</ul>
<h3 id="thinking-4-9">Thinking 4.9</h3>
<blockquote>
<p>请思考并回答以下几个问题：</p>
<ul>
<li>为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</li>
<li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li>
</ul>
</blockquote>
<ul>
<li>解：
<ul>
<li><code>syscall_exofork()</code>返回后父子进程各自执行自己的进程，子进程需要修改<code>entry.S</code>中定义的env指针，涉及到对COW页面的修改，会触发COW写入异常，COW中断的处理机制依赖于<code>syscall_set_tlb_mod_entry</code>，所以将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前；</li>
<li>父进程在调用写时复制保护机制可能会引发缺页异常，而异常处理未设置好，则不能正常处理。</li>
</ul>
</li>
</ul>
<h2 id="实验体会">实验体会</h2>
<h3 id="system-call">System Call</h3>
<p><img src="/2023/05/15/BUAA-OS-4/lab4-1.jpg" alt="lab4-1"></p>
<h4 id="系统调用实例">系统调用实例</h4>
<ul>
<li>
<p><code>syscall</code></p>
<p>用于执行系统调用的<strong>自陷指令</strong>，它使得进程陷入到<strong>内核的异常处理程序</strong>中，由内核根据系统调用时的上下文执行相应的内核函数，完成相应的功能，并最终返回到 syscall 的后一条指令。</p>
</li>
<li>
<p>系统调用的层次结构</p>
<table>
<thead>
<tr>
<th>高级</th>
<th>用户程序 User Program</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>应用程序编程接口 API</td>
<td>POSIX, C Standard Library等</td>
</tr>
<tr>
<td>最底层</td>
<td>系统调用</td>
<td>read, write 等</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="系统调用机制的实现">系统调用机制的实现</h4>
<ul>
<li>
<p><em>syscall</em> 过程流程图</p>
<img src="/2023/05/15/BUAA-OS-4/syscall.png" alt="syscall" style="zoom:67%;">
<p>【系统调用使用流程】：</p>
<ul>
<li>
<p><code>syscall_*</code> （user/lib/syscall_lib.c）</p>
<p>该函数构成非常简单，只有一句话：调用<code>msyscall</code>函数</p>
<ul>
<li>
<p><code>msyscall</code> （user/lib/syscall_wrap.S）</p>
<p>该函数构成也非常简单，两步：调用<code>syscall</code>函数 + <code>jr ra</code>返回</p>
<p>（<code>SYS_*</code> 系统调用号是在 include/syscall.h 里面定义的）</p>
<ul>
<li>
<p><code>syscall</code> （kern/entry.S）</p>
<ol>
<li>使用 <code>SAVE_ALL</code> 宏：将用户进程的上下文运行环境保存在内核栈中</li>
<li>取出 <code>CP0_CAUSE</code> 寄存器中的异常码，系统调用对应的异常码为 <code>8</code></li>
<li>以异常码为索引在 <code>exception_handlers</code>数组中找到对应异常处理函数<code>handle_sys</code></li>
<li>转跳至 <code>handle_sys</code> 函数处理用户的系统调用请求</li>
</ol>
<ul>
<li>
<p><code>SAVE_ALL</code> （include/stackframe.h）</p>
<p>在保存用户态现场时 <code>sp</code> 减去了一个 <code>Trapframe</code> 结构体的空间大小，此时我们将用户进程现场保存在内核栈中范围为 <code>[sp, sp + sizeof(TrapFrame))</code> 的这一空间范围内</p>
</li>
<li>
<p><code>handle_sys</code> 用宏<code>BUILD_HANDLER</code> 实现 （kern/genex.S）</p>
<ol>
<li>由 <code>SAVE_ALL</code> 得到的 <code>sp</code> 寄存器中保存的是 Trapframe 结构体的起始地址，将该起始地址存入 <code>a0</code> 寄存器作为 <code>do_syscall</code> 的传入参数</li>
<li>调用 <code>do_syscall</code> 实现处理系统调用</li>
<li>调用 <code>ret_from_exception</code> 从内核态返回用户程序</li>
</ol>
<ul>
<li>
<p><code>do_syscall</code> （kern/syscall_all.c）</p>
<ol>
<li>改 epc 使得由内核态返回用户态之后能够执行<code>msyscall</code>函数中的<code>jr ra</code>指令</li>
<li>获得参数，通过 <code>func(arg1, arg2, arg3, arg4, arg5)</code> 直接调用内核中相应的系统调用函数， 也就是 <code> sys_*</code> 函数</li>
</ol>
<ul>
<li><code>sys_*</code> （kern/syscall_all.c）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>syscall_*</code> 和 <code>sys_*</code></p>
<p><code>syscall_*</code> 的函数与内核中的系统调用函数（<code>sys_*</code> 的函数）是<strong>一一对应</strong>的；</p>
<ul>
<li><code>syscall_*</code> 的函数是我们在用户空间中最接近的内核的函数（<em>不允许</em> 在<em>延迟槽</em> 中使用 ）；</li>
<li><code>sys_*</code> 的函数是内核中系统调用的具体实现部分。</li>
</ul>
</li>
<li>
<p><code>msyscall</code></p>
<ul>
<li>
<p>每个 <code>syscall_*</code> 都调用了函数 <code>msyscall</code>，<code>msyscall</code>的<strong>第一个参数</strong>都是一个与调用名相似的宏（如 <code>SYS_print_cons</code>），我们叫这个参数为<strong>系统调用号</strong>（定义在 <em>include/syscall.h</em> 中 ）。</p>
<p>除了系统调用号之外，<code>msyscall</code> 还有5个参数，这些参数是系统调用时需要传递给内核的参数。 （之所以还要另外的5个参数，是因为系统调用所需要的最多参数数量，就是是“<code>syscall_mem_map</code>函数需要 5 个参数 ”）</p>
</li>
<li>
<p><code>msyscall</code>函数是<strong>叶函数</strong>，<strong>没有局部变量</strong>，<strong>不需要分配栈帧</strong>，只需执行自陷指令 syscall 来陷入内核态并在处理结束后正常返回即可。</p>
</li>
</ul>
</li>
<li>
<p><em>stack frame</em> 栈帧</p>
<ul>
<li>
<p>栈帧：<strong>进入函数体时</strong>会通过<strong>对栈指针做减法（压栈）<strong>的方式为该函数自身的<em>局部变量、返回地址、调用函数的参数</em>分配存储空间，在</strong>函数调用结束</strong>之后会**对栈指针做加法（弹栈）**来释放这部分空间  ，该空间就是<em>栈帧</em>。</p>
<ul>
<li><strong>调用方</strong>在自身栈帧的底部预留被调用函数的参数存储空间，由<strong>被调用方</strong>从调用方的栈帧中读取参数</li>
</ul>
</li>
<li>
<p>寄存器 $a0-$a3 用于存放函数调用的前四个参数（但在栈中仍然需要为其<strong>预留空间</strong>），剩余的参数<strong>仅</strong>存放在栈中。</p>
<ul>
<li>
<p>例子：<code>msyscall</code> 函数一共有 6 个参数，前 4 个参数会被 <code>syscall_*</code> 的函数分别存入 $a0-$a3 寄存器（<strong>寄存器传参的部分</strong>）同时栈帧底部<strong>保留</strong> 16 字节的空间（<strong>不要求存入参数的值</strong>），后 2 个参数只会被存入在预留空间<strong>之上</strong>的 8 字节空间内（<strong>没有寄存器传参</strong>），于是<strong>总共</strong> 24 字节的空间用于参数传递。</p>
<img src="/2023/05/15/BUAA-OS-4/stack.png" alt="stack" style="zoom:67%;">
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>void do_syscall(struct Trapframe *tf)  </code></p>
<ul>
<li>功能：</li>
<li>使用例子：</li>
<li>实现：</li>
</ul>
</li>
<li>
<p>往年通信：</p>
<p>实现思路如下：</p>
<ul>
<li>选择开一个结构体数组记录每次信息发送的相关值和一个记录是否完成的标记。</li>
<li>接收进程：首先查表，有无自己可以接受的信息，有的话就接收，设置发送进程状态为RUNNABLE 并正常退出，否则阻塞。</li>
<li>发送进程：检查接收进程的状态，若阻塞，直接进程信息发送同时设置接收进程状态为RUNNABLE。若接收进程没有阻塞，将待发送的信息添加到信息表中，阻塞。</li>
</ul>
</li>
</ul>
<h3 id="fork">fork</h3>
<ul>
<li>
<p>要查看系统调用就去 user/lib/syscall_lib.c 和 syscall_all.c 文件中看吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> envs ((volatile struct Env *)UENVS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pages ((volatile struct Page *)UPAGES)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096		<span class="comment">// bytes to a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDMAP (4 * 1024 * 1024) <span class="comment">// bytes mapped by a page directory entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDSHIFT 22 <span class="comment">// log2(PDMAP)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03FF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03FF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Page number field of an address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(va) (((u_long)(va)) &gt;&gt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN(va) (((u_long)(va)) &gt;&gt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUND(a, n) (((((u_long)(a)) + (n)-1)) &amp; ~((n)-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUNDDOWN(a, n) (((u_long)(a)) &amp; ~((n)-1))</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>int fork(void)</code> (user/lib/fork.c)</p>
<ul>
<li>
<p>【注意】： <code>env = envs + ENVX(syscall_getenvid());</code></p>
<p>syscall_getenvid()：获得当前进程的envid</p>
<p>envs + ENVX(…) : 由envid获得env</p>
</li>
<li>
<p>【注意】</p>
<ul>
<li>
<p>vpd是<strong>页目录首地址</strong>，以vpd为基地址，加上页目录项偏移数即可<strong>指向va对应页目录项</strong>，即<code>(*vpd) + (va &gt;&gt; 22)</code> 或 <code>vpd[va &gt;&gt; 22]</code> ；</p>
<p><strong>二级页表的物理地址</strong>：<code>vpd[va &gt;&gt; 22] &amp; (~0xfff)</code></p>
<p><strong>提前判断有效位</strong>： <code>(vpd[va &gt;&gt; 22] &amp; PTE_V)</code> 或 <code>(vpd[VPN(va) &gt;&gt; 10] &amp; PTE_V)</code></p>
</li>
<li>
<p>vpt是<strong>页表首地址</strong>，以vpt为基地址，加上页表项偏移数即可<strong>指向va对应的页表项</strong>，即<code>(*vpt) + (va &gt;&gt; 12)</code> 或 <code>vpt[va &gt;&gt; 12]</code> 即 <code>vpt[VPN(va)]</code>；</p>
<p><strong>物理页面地址</strong>：<code>vpt[va &gt;&gt; 12] &amp; (~0xfff)</code></p>
<p><strong>提前判断有效位</strong>：  <code>(vpt[va &gt;&gt; 12] &amp; PTE_V)</code> 或 <code>(vpt[VPN(va)] &amp; PTE_V)</code></p>
</li>
<li>
<p>vpn = VPN(va) = va &gt;&gt; 12（ 虚拟页号）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>static void ... cow_entry(...)</code> (user/lib/fork.c)</p>
</li>
</ul>
<h4 id="往年题lab4-2-exam">往年题lab4-2-exam</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">make_shared</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line">    u_int perm = PTE_D | PTE_V;</span><br><span class="line">    <span class="keyword">if</span> (!(vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) || !(vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V)) &#123; </span><br><span class="line">        <span class="comment">//当前进程的页表中不存在该虚拟页</span></span><br><span class="line">        <span class="keyword">if</span> (syscall_mem_alloc(<span class="number">0</span>, ROUNDDOWN(va, BY2PG), perm) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//将envid设为0，表示默认curenv</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    perm = vpt[VPN(va)] &amp; <span class="number">0xfff</span>; <span class="comment">//获得va的perm</span></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= (<span class="type">void</span> *)UTOP || </span><br><span class="line">        ((vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) &amp;&amp; (vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V) &amp;&amp; !(perm &amp; PTE_D))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    perm = perm | PTE_LIBRARY;</span><br><span class="line">    u_int addr = VPN(va) * BY2PG; </span><br><span class="line">    <span class="keyword">if</span> (syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)addr, <span class="number">0</span>, (<span class="type">void</span> *)addr, perm) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> ROUNDDOWN(vpt[VPN(va)] &amp; (~<span class="number">0xfff</span>), BY2PG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>附：由于<code>ROUNDDOWN(va, BY2PG)</code> 本质上将后12位置0，所以对于 <code>vpd[]</code> 、<code>vpt[]</code> 并无影响，但是对于 <code>syscall_mem_map</code>  还是有影响的。</li>
</ul>
<h2 id="难点分析">难点分析</h2>
<ul>
<li>
<p><code>Trapframe</code> 结构体中 <code>regs[32]</code> 的各个含义：</p>
<table>
<thead>
<tr>
<th>Reg</th>
<th>Name</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>zero</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>at</td>
<td></td>
</tr>
<tr>
<td>2-3</td>
<td>v0-v1</td>
<td></td>
</tr>
<tr>
<td>4-7</td>
<td>a0-a3</td>
<td></td>
</tr>
<tr>
<td>8-15</td>
<td>t0-t7</td>
<td></td>
</tr>
<tr>
<td>24-25</td>
<td>t8-t9</td>
<td></td>
</tr>
<tr>
<td>16-23</td>
<td>s0-s7</td>
<td></td>
</tr>
<tr>
<td>26-27</td>
<td>k0-k1</td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>gp</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>sp</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>s8/fp</td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>ra</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="课上测试">课上测试</h3>
<h4 id="lab4-1-exam">lab4-1-Exam</h4>
<p>​    主要考察添加一个系统调用的步骤，如下以<strong>用户进程调用函数 <code>user_lib_func(u_int whom, u_int val, const void *srcva, u_int perm)</code> 过程中，会使用到系统调用 <code>syscall_func</code></strong> 为例归纳步骤：</p>
<ol>
<li>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>c</mi><mi>l</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">user/include/lib.h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">.</span><span class="mord mathdefault">h</span></span></span></span> 中添加：</p>
<p><code>void user_lib_func(u_int whom, u_int val, const void *srcva, u_int perm);</code></p>
<p><code>void syscall_func(u_int envid, u_int value, const void *srcva, u_int perm);</code></p>
</li>
<li>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">user/lib/syscall\_lib.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 中添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_func</span><span class="params">(u_int envid, u_int value, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    msyscall(SYS_func, envid, value, srcva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">user/lib</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span></span></span></span> 中的使用 <code>user_lib_func</code> 函数的目标文件中编写实现该函数（注意在该函数过程中会调用 <code>syscall_func</code> 函数）</p>
</li>
<li>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>l</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">.</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">include/syscall.h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">.</span><span class="mord mathdefault">h</span></span></span></span> 中的<code>enum</code> 的<code>MAX_SYSNO</code> <strong>前面</strong>加上 <code>SYS_func,</code></p>
</li>
<li>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">kern/syscall\_all.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 的 <code>void *syscall_table[MAX_SYSNO]</code> 的<strong>最后</strong>加上 <code>[SYS_func] = sys_func,</code> （注意最后有逗号）</p>
</li>
<li>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">kern/syscall\_all.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 的 <code>void *syscall_table[MAX_SYSNO]</code> 的<strong>前面</strong>具体编写实现函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_func</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="lab4-1-extra">lab4-1-Extra</h4>
<p>​     lab4-1-extra需要实现一种广播通讯机制<code>ipc_broadcast</code>函数，具体题目见文章<a target="_blank" rel="noopener" href="https://yanna-zy.gitee.io/file/2023-BUAA-OS-4-ExtraStem.pdf">Lab4-1-Extra-Broadcast题干</a>。</p>
<p>​     主要在于引入全局变量<code>envs</code>数组，然后遍历判断后代进程。</p>
<ul>
<li>
<p>我的答案：【太感动了~ 小女子菜菜，本学期第一次拿到 extra 的100分  感激涕零ing】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/syscall_all.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> <span class="title">envs</span>[<span class="title">NENV</span>];</span> <span class="comment">//注意 extern！！</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_broadcast</span><span class="params">(u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;srcva&#x27; is either zero or a legal address. */</span></span><br><span class="line">	<span class="comment">/* 抄的sys_ipc_try_send */</span></span><br><span class="line">	<span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 函数核心：遍历envs找后代进程 */</span></span><br><span class="line">	<span class="type">int</span> signal[NENV];</span><br><span class="line">	<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_id == envs[i].env_parent_id) &#123;</span><br><span class="line">			signal[i] = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			signal[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (signal[i] == <span class="number">1</span>) &#123;</span><br><span class="line">    				<span class="keyword">for</span> (u_int j = <span class="number">0</span>; j &lt; NENV; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (signal[j] == <span class="number">0</span> &amp;&amp; envs[i].env_id == envs[j].env_parent_id) &#123;</span><br><span class="line">						signal[j] = <span class="number">1</span>;</span><br><span class="line">						flag = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Step 3: Check if the target is waiting for a message. */</span></span><br><span class="line">	<span class="comment">/* 基于sys_ipc_try_send修改 */</span></span><br><span class="line">	<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(signal[i] == <span class="number">1</span>) &#123;</span><br><span class="line">			e = &amp;(envs[i]);</span><br><span class="line">            <span class="comment">/* 以下都是抄的sys_ipc_try_send */</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">			&#125;</span><br><span class="line">			e-&gt;env_ipc_value = value;</span><br><span class="line">			e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">			e-&gt;env_ipc_perm = PTE_V | perm;</span><br><span class="line">			e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">			e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">			TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">			<span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">				p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">				<span class="keyword">if</span> (page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm) != <span class="number">0</span>) &#123; </span><br><span class="line">		            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"> 		       &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>附：我后续在完成lab4-2的任务时，发现有一个 <code>env = envs + ENVX(envid);</code> 可以由 envid得到 env</p>
</li>
</ul>
<h4 id="lab4-2-exam">lab4-2-Exam</h4>
<ul>
<li>
<p>考察：系统调用+fork+ipc</p>
<p>最终只得分了70分，具体原因还在求助老师和助教中。</p>
<p>【后来重测啦~  下面的三种写法都是100分~ 耶耶耶！！！！】</p>
</li>
<li>
<p>版本1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试数据点3和6不过,得分55分</span></span><br><span class="line">u_int <span class="title function_">sys_barrier_wait</span><span class="params">(u_int* p_barrier_num, u_int* p_barrier_useful)</span> &#123;</span><br><span class="line">	<span class="type">static</span> u_int env_not[<span class="number">100</span>];</span><br><span class="line">	<span class="type">static</span> u_int N = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u_int num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u_int useful = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((*p_barrier_num) &gt; N) &#123;</span><br><span class="line">		N = (*p_barrier_num);</span><br><span class="line">		num = N;</span><br><span class="line">		useful = (*p_barrier_useful);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (useful == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; N - num; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (env_not[i] == curenv-&gt;env_id) &#123;</span><br><span class="line">					<span class="keyword">return</span> ENV_NOT_RUNNABLE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		env_not[N - num] = curenv-&gt;env_id;</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123; <span class="comment">//first version</span></span><br><span class="line">				useful = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> ENV_RUNNABLE;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> ENV_NOT_RUNNABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ENV_RUNNABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>版本2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试数据点6不过，得分70分</span></span><br><span class="line">u_int <span class="title function_">sys_barrier_wait</span><span class="params">(u_int* p_barrier_num, u_int* p_barrier_useful)</span> &#123;</span><br><span class="line">	<span class="type">static</span> u_int env_not[<span class="number">100</span>];</span><br><span class="line">	<span class="type">static</span> u_int N = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u_int num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u_int useful = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((*p_barrier_num) &gt; N) &#123;</span><br><span class="line">		N = (*p_barrier_num);</span><br><span class="line">		num = N;</span><br><span class="line">		useful = (*p_barrier_useful);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (useful == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123; <span class="comment">//second version</span></span><br><span class="line">				useful = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> ENV_RUNNABLE;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; N - num; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (env_not[i] == curenv-&gt;env_id) &#123;</span><br><span class="line">					<span class="keyword">return</span> ENV_NOT_RUNNABLE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		env_not[N - num] = curenv-&gt;env_id;</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">return</span> ENV_NOT_RUNNABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ENV_RUNNABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>版本3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经过和其他同学的讨论，以及代码对拍，下面这个代码可能可以得100分</span></span><br><span class="line">u_int <span class="title function_">sys_barrier_wait</span><span class="params">(u_int* p_barrier_num, u_int* p_barrier_useful)</span> &#123;</span><br><span class="line">	<span class="type">static</span> u_int env_not[<span class="number">100</span>];</span><br><span class="line">	<span class="type">static</span> u_int N = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u_int num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u_int useful = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((*p_barrier_num) &gt; N) &#123;</span><br><span class="line">		N = (*p_barrier_num);</span><br><span class="line">		num = N;</span><br><span class="line">		useful = (*p_barrier_useful);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">0</span>) &#123; <span class="comment">//third version</span></span><br><span class="line">			useful = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> ENV_RUNNABLE;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (useful == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; N - num; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (env_not[i] == curenv-&gt;env_id) &#123;</span><br><span class="line">					<span class="keyword">return</span> ENV_NOT_RUNNABLE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		env_not[N - num] = curenv-&gt;env_id;</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">return</span> ENV_NOT_RUNNABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ENV_RUNNABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="lab4-2-extra">lab4-2-Extra</h4>
<p>【哭唧唧~ exam没做出来，extra连题目都没看，只是据说很难~】</p>
<h2 id="体会与感想">体会与感想</h2>
<p>​       lab4主要需要掌握：系统调用，IPC通信机制，fork进程创建，页面写入异常处理。</p>
<p>​       在本次实验中，脑子里一定要清楚现在是在改内核还是改用户，因为之前写的都是内核，而内核函数是不能在用户空间调用的，这一点要注意区分。</p>
<p>​      让人很难受的是，自己的lab4-2-exam挂了，感觉非常无助，一方面个人觉得题目的表述不是很清晰，另一方面也自己反思还是五一假期过于沉溺与玩乐了。</p>
<p>​      总之，lab4要想获得比较好的成绩，还是需要投入大量的时间和精力。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">YannaZhang 张杨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/15/BUAA-OS-4/">http://example.com/2023/05/15/BUAA-OS-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YannaのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA-OS/">BUAA-OS</a></div><div class="post_share"><div class="social-share" data-image="/img/series1/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/18/BUAA-OS-3/" title="BUAA-OS-lab3"><img class="cover" src="/img/series1/6.png" onerror="onerror=null;src='/img/archive_img.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OS-lab3</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/19/BUAA-OO-3/" title="BUAA-OO-第三单元：规格化设计"><img class="cover" src="/img/series1/10.png" onerror="onerror=null;src='/img/archive_img.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OO-第三单元：规格化设计</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/19/BUAA-OS-0/" title="BUAA-OS-lab0"><img class="cover" src="/img/series1/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">BUAA-OS-lab0</div></div></a></div><div><a href="/2023/03/19/BUAA-OS-1/" title="BUAA-OS-lab1"><img class="cover" src="/img/series1/2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">BUAA-OS-lab1</div></div></a></div><div><a href="/2023/04/10/BUAA-OS-2/" title="BUAA-OS-lab2"><img class="cover" src="/img/series1/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">BUAA-OS-lab2</div></div></a></div><div><a href="/2023/04/18/BUAA-OS-3/" title="BUAA-OS-lab3"><img class="cover" src="/img/series1/6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">BUAA-OS-lab3</div></div></a></div><div><a href="/2023/05/19/BUAA-OS-5/" title="BUAA-OS-lab5"><img class="cover" src="/img/series1/8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="title">BUAA-OS-lab5</div></div></a></div><div><a href="/2023/06/18/BUAA-OS-challenge/" title="BUAA-OS-lab4-challenge"><img class="cover" src="/img/series1/9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-18</div><div class="title">BUAA-OS-lab4-challenge</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">Lab4实验报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">Thinking 4.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-2"><span class="toc-number">1.1.2.</span> <span class="toc-text">Thinking 4.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-3"><span class="toc-number">1.1.3.</span> <span class="toc-text">Thinking 4.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-4"><span class="toc-number">1.1.4.</span> <span class="toc-text">Thinking 4.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-5"><span class="toc-number">1.1.5.</span> <span class="toc-text">Thinking 4.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-6"><span class="toc-number">1.1.6.</span> <span class="toc-text">Thinking 4.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-7"><span class="toc-number">1.1.7.</span> <span class="toc-text">Thinking 4.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-8"><span class="toc-number">1.1.8.</span> <span class="toc-text">Thinking 4.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-4-9"><span class="toc-number">1.1.9.</span> <span class="toc-text">Thinking 4.9</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BD%93%E4%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">实验体会</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system-call"><span class="toc-number">1.2.1.</span> <span class="toc-text">System Call</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">系统调用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">系统调用机制的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">1.2.2.</span> <span class="toc-text">fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E9%A2%98lab4-2-exam"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">往年题lab4-2-exam</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">难点分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">课上测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lab4-1-exam"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">lab4-1-Exam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lab4-1-extra"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">lab4-1-Extra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lab4-2-exam"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">lab4-2-Exam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lab4-2-extra"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">lab4-2-Extra</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E4%BC%9A%E4%B8%8E%E6%84%9F%E6%83%B3"><span class="toc-number">1.4.</span> <span class="toc-text">体会与感想</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/post_img.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By YannaZhang 张杨</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'sVaqAurlJUIUiRSl4GxSzMoi-gzGzoHsz',
      appKey: 'BCXg41m5wCxza144wQyhXZzv',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/sakura.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>