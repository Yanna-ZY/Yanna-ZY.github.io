<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>BUAA-OS-lab5 | YannaのBlog</title><meta name="author" content="YannaZhang 张杨"><meta name="copyright" content="YannaZhang 张杨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab5实验报告 思考题 Thinking 5.1  如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。 请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。   解：  当外部设备产生中断信号或者更新数据时，">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-lab5">
<meta property="og:url" content="http://example.com/2023/05/19/BUAA-OS-5/index.html">
<meta property="og:site_name" content="YannaのBlog">
<meta property="og:description" content="Lab5实验报告 思考题 Thinking 5.1  如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。 请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。   解：  当外部设备产生中断信号或者更新数据时，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/series1/8.png">
<meta property="article:published_time" content="2023-05-19T09:21:10.000Z">
<meta property="article:modified_time" content="2023-06-19T08:56:19.059Z">
<meta property="article:author" content="YannaZhang 张杨">
<meta property="article:tag" content="BUAA-OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/series1/8.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/19/BUAA-OS-5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: YannaZhang 张杨","link":"链接: ","source":"来源: YannaのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-lab5',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-19 16:56:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/archive_img.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 扉页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 光阴簿</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 签轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 编类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 籍</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 曲籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-commenting"></i><span> 留音笺</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 卿</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 予</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="YannaのBlog"><span class="site-name">YannaのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 扉页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 光阴簿</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 签轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 编类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 籍</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 曲籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-commenting"></i><span> 留音笺</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 卿</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 予</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-lab5</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-19T09:21:10.000Z" title="发表于 2023-05-19 17:21:10">2023-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-19T08:56:19.059Z" title="更新于 2023-06-19 16:56:19">2023-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%BB%E5%BE%B7%EF%BC%88%E5%AD%A6%E4%B9%A0%EF%BC%89/">养德（学习）</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-lab5"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="lab5实验报告">Lab5实验报告</h1>
<h2 id="思考题">思考题</h2>
<h3 id="thinking-5-1">Thinking 5.1</h3>
<blockquote>
<p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。</p>
<p>请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</p>
</blockquote>
<ul>
<li>解：
<ul>
<li>当外部设备产生中断信号或者更新数据时，此时Cache中之前旧的数据可能刚完成缓存，那么完成缓存的这一部分无法完成更新，则会发生错误的行为。</li>
<li>对于串口设备来说，读写频繁，信号多，在相同的时间内发生错误的概论远高于IDE磁盘。</li>
</ul>
</li>
</ul>
<h3 id="thinking-5-2">Thinking 5.2</h3>
<blockquote>
<p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br></pre></td></tr></table></figure>
<ul>
<li>文件控制块结构体中，有这样的一个属性 <code>f_pad</code> ，大小为 <code>BY2FILE </code>即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">256B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，则代表一个文件控制块的大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">256B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，那么一个磁盘块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 最多存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>256</mn><mi>B</mi><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">4KB/256B=16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 个文件控制块。</li>
<li>一个目录 = 一个磁盘块全部用来存目录项，又一个目录项<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mtext>位</mtext><mo>=</mo><mn>4</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">32位 = 4B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord cjk_fallback">位</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>；则一个目录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，一个目录中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi>B</mi><mo>=</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">4KB/4B=1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span> 个目录项；又一个目录项指向一个存有文件内容的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 磁盘块，一个磁盘块中有16个文件控制块，则一个目录下最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>16384</mn><mo>=</mo><mn>16</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">1024*16=16384=16K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">3</span><span class="mord">8</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 个文件。</li>
<li>一个文件控制块，描述一个文件；一个文件有 <strong>直接指针 + 间接指针</strong> 共1024个 ，每个指针指向一个磁盘块，存储着该文件的一部分文件数据。文件系统支持的单个文件最大，则表示1024个指针全部有效，一共指向了1024个磁盘块存着文件数据，又一个磁盘块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，则单个文件最大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>∗</mo><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><mn>4</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1024*4KB=4MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。</li>
</ul>
</li>
</ul>
<h3 id="thinking-5-3">Thinking 5.3</h3>
<blockquote>
<p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>由于将 <code>DISKMAP ~ DISKMAP+DISKMAX</code> 这一段虚存地址空间作为<strong>缓冲区</strong>， <code>DISKMAX</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>40000000</mn></mrow><annotation encoding="application/x-tex">0x40000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> ，因此最多处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。</li>
</ul>
</li>
</ul>
<h3 id="thinking-5-4">Thinking 5.4</h3>
<blockquote>
<p>在本实验中， fs/serv.h、 user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p><code>user/include/fd.h</code> 这两个宏用来找 <code>fd</code> 对应的<strong>文件信息页面</strong>和<strong>文件缓存区地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>文件服务函数调用号</strong>，可以重用 $user/lib/fsipc.c $ 的 <code>fsipc()</code> 函数，作为进程间通信的值，用户进程传给文件服务系统的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">fs/serv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的 <code>serve()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-5-5">Thinking 5.5</h3>
<blockquote>
<p>在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<ul>
<li>
<p>fork 前后的父子进程共享文件描述符和定位指针</p>
</li>
<li>
<p>验证程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *msg = <span class="string">&quot;This is the NEW message of the day!\n\n&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *diff_msg = <span class="string">&quot;This is a different massage of the day!\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">umain</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="type">int</span> fdnum;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;open /newmotd: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        fdnum = r;</span><br><span class="line">        writef(<span class="string">&quot;open is good\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((n = read(fdnum, buf, <span class="number">511</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;read /newmotd: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, diff_msg) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;read returned wrong data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writef(<span class="string">&quot;read is good\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((id = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = read(fdnum, buf, <span class="number">511</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;child read /newmotd: %d&quot;</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, diff_msg) != <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;child read returned wrong data&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writef(<span class="string">&quot;child read is good &amp;&amp; child_fd == %d\n&quot;</span>,r);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fdd</span>;</span></span><br><span class="line">            fd_lookup(r,&amp;fdd);</span><br><span class="line">            writef(<span class="string">&quot;child_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((n = read(fdnum, buf, <span class="number">511</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;father read /newmotd: %d&quot;</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, diff_msg) != <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;father read returned wrong data&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writef(<span class="string">&quot;father read is good &amp;&amp; father_fd == %d\n&quot;</span>,r);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fdd</span>;</span></span><br><span class="line">            fd_lookup(r,&amp;fdd);</span><br><span class="line">            writef(<span class="string">&quot;father_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">main.c: main is start ...</span><br><span class="line">init.c: mips_init() is called</span><br><span class="line">Physical memory: 65536K available, base = 65536K, extended = 0K</span><br><span class="line">to memory 80401000 for struct page directory.</span><br><span class="line">to memory 80431000 for struct Pages.</span><br><span class="line">pmap.c:  mips vm init success</span><br><span class="line">pageout:        @@@___0x7f3fe000___@@@  ins a page </span><br><span class="line">pageout:        @@@___0x40d000___@@@  ins a page </span><br><span class="line">FS is running</span><br><span class="line">FS can do I/O</span><br><span class="line">pageout:        @@@___0x7f3fe000___@@@  ins a page </span><br><span class="line">pageout:        @@@___0x407000___@@@  ins a page </span><br><span class="line">superblock is good</span><br><span class="line">diskno: 0</span><br><span class="line">diskno: 0</span><br><span class="line">read_bitmap is good</span><br><span class="line">diskno: 0</span><br><span class="line">alloc_block is good</span><br><span class="line">file_open is good</span><br><span class="line">file_get_block is good</span><br><span class="line">file_flush is good</span><br><span class="line">file_truncate is good</span><br><span class="line">diskno: 0</span><br><span class="line">file rewrite is good</span><br><span class="line">serve_open 00000400 ffff000 0x2</span><br><span class="line">open is good</span><br><span class="line">read is good</span><br><span class="line">father read is good &amp;&amp; father_fd == 0</span><br><span class="line">father_fd&#x27;s offset == 41</span><br><span class="line">[00000400] destroying 00000400</span><br><span class="line">[00000400] free env 00000400</span><br><span class="line">i am killed ... </span><br><span class="line">child read is good &amp;&amp; child_fd == 0</span><br><span class="line">child_fd&#x27;s offset == 41</span><br><span class="line">[00001402] destroying 00001402</span><br><span class="line">[00001402] free env 00001402</span><br><span class="line">i am killed ... </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="thinking-5-6">Thinking 5.6</h3>
<blockquote>
<p>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p>
</blockquote>
<ul>
<li>
<p>解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// 文件名称,最大长度MAXNAMELEN值为128</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size; <span class="comment">// 文件的大小，单位:字节</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type; <span class="comment">// 文件类型:  普通文件FTYPE_REG，目录FTYPE_DIR</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];<span class="comment">// 文件的直接指针,用来记录文件的数据块在磁盘上的位置</span></span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;<span class="comment">// 指向一个间接磁盘块，用来存储指向文件内容的磁盘块的指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// 指向文件所属的文件目录</span></span><br><span class="line">	<span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">    <span class="comment">//为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">     u_int fd_dev_id;     <span class="comment">// 外设的id。</span></span><br><span class="line">     <span class="comment">//用户使用fd.c的文件接口时，不同的dev_id会调取不同的文件服务函数。</span></span><br><span class="line">     <span class="comment">//比如File类型的文件服务函数为user/File.c的file_*()函数。</span></span><br><span class="line">     u_int fd_offset;     <span class="comment">// 读写的偏移量</span></span><br><span class="line">     <span class="comment">//seek()时修改。</span></span><br><span class="line">     <span class="comment">//offset会被用来找起始filebno文件块号。</span></span><br><span class="line">     u_int fd_omode;      <span class="comment">// 打开方式，包括只读、只写、读写</span></span><br><span class="line">     <span class="comment">//req和open结构体都会用到</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span>     <span class="comment">// file descriptor</span></span><br><span class="line">     u_int f_fileid;     <span class="comment">// 文件的id</span></span><br><span class="line">     <span class="comment">//模1024后会用来在opentab[]里索引open结构体</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">// 对应文件的文件控制块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体均为内存数据，记录了文件信息。</li>
<li><code>Filefd</code> 以及 <code>fd</code> 中的指向的文件控制块 <code>File</code> 中记录的磁盘指针对应物理实体。</li>
</ul>
</li>
</ul>
<h3 id="thinking-5-7">Thinking 5.7</h3>
<blockquote>
<p>下图（文件系统服务时序图）中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p>
</blockquote>
<img src="/2023/05/19/BUAA-OS-5/1.png" alt="image-20230509001916040" style="zoom: 80%;">
<ul>
<li>解：
<ul>
<li><code>ENV_CREATE(user_env)</code> 和 <code>ENV_CREATE(fs_serv)</code> 都是异步消息，由 <code>init()</code> 发出创建消息后， <code>init()</code> 函数即可返回执行后续步骤，由 <code>fs</code> 和 <code>user</code> 线程执行自己的初始化工作。</li>
<li><code>fs</code> 线程初始化 <code>serv_init()</code> 和 <code>fs_init()</code> 完成后，进入 <code>serv()</code> 函数，被 <code>ipc_receive()</code> 阻塞为<code>ENV_NOT_RUNNABLE</code> ，直到收到 <code>user</code> 线程的 <code>ipc_send(fsreq)</code> 被唤醒。</li>
<li><code>user</code> 线程向 <code>fs</code> 线程 <code>ipc_send(fsreq)</code> 发送请求为同步消息，发送后自身进入阻塞<code>ENV_NOT_RUNNABLE</code> 等待被唤醒的fs线程服务结束时 <code>ipc_send(dst_va)</code> ,用户线程接收到数据后继续运行，此后 <code>fs</code> 线程进入阻塞，等待下次被用户唤醒。</li>
</ul>
</li>
</ul>
<h2 id="实验体会">实验体会</h2>
<h3 id="文件系统概述">文件系统概述</h3>
<ul>
<li>文件设备（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">file</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>，即狭义的“文件”）、控制台（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">console</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>）和管道（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">pipe</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span></span></span></span>）</li>
</ul>
<h4 id="文件系统的设计与实现">文件系统的设计与实现</h4>
<p>核心代码文件的主要功能（协助理解文件系统实现的总体框架）：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">tools</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span></span></span></span> 目录中存放的是构建时辅助工具的代码：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">fsformat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span></span></span></span> 工具  ——创建磁盘镜像</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">fs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 目录中存放的是文件系统服务进程的代码：通过IPC通信与用户进程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>f</mi><mi>s</mi><mi>i</mi><mi>p</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">user/lib/fsipc.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 内的通信函数进行交互
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">fs.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span>​ ：实现文件系统的基本功能函数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ide.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span>：通过系统调用与磁盘镜像进行交互</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">serv.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> ：进程的主干函数</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">user/lib</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span></span></span></span>​ 目录下存放了用户程序的库函数：允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi>i</mi><mi>p</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">fsipc.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> ：实现与文件系统服务进程的交互</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">file.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> ：实现文件系统的用户接口</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">fd.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> ：实现文件描述符</li>
</ul>
</li>
</ul>
<h3 id="一-ide磁盘驱动">一、IDE磁盘驱动</h3>
<p>该驱动程序将通过系统调用的方式陷入内核，对磁盘镜像进行读写操作（按一定顺序读写设备寄存器，来实现对外部设备的操作）。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">kern/console.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> ：一个简单的控制台驱动程序</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>M</mi><mi>I</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">MMIO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> ：在内核下使用内存映射I/O（MMIO）技术，通过控制台实现字符的输入输出</li>
<li>磁盘驱动程序采用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>M</mi><mi>I</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">MMIO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> 技术编写驱动，且本次要编写的驱动程序完全运行在用户空间</li>
</ul>
<h4 id="1-mmio：内存映射i-o">1、MMIO：内存映射I/O</h4>
<p>外设是通过读写设备上的寄存器来进行数据通信，<strong>外设寄存器</strong>也称为 <strong>I/O 端口</strong>，主要用来访<br>
问 I/O 设备。外设寄存器通常包括<strong>控制寄存器</strong>、<strong>状态寄存器</strong>和<strong>数据寄存器</strong>，这些寄存器被映射<br>
到指定的<strong>物理地址空间</strong>。  （例如：在 GXemul 中， console 设备被映射到 0x10000000， simulated IDE disk 被映射到 0x13000000，等等  ）</p>
<p>在 MIPS 的内核地址空间中（kseg0 和 kseg1 段）实现了硬件级别的<em>物理地址和内核虚拟地址的转换机制</em>，其中，对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>s</mi><mi>e</mi><mi>g</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">kseg1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">1</span></span></span></span> 段地址的读写<strong>不经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>M</mi><mi>U</mi></mrow><annotation encoding="application/x-tex">MMU</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> 映射，且不使用高速缓存</strong>，这正是外部设备驱动所需要的。因为我们是模拟的，所以可以通过简单地读写<strong>某些固定的内核虚拟地址</strong>来实现驱动程序的功能。</p>
<ul>
<li>
<p>物理地址 ==&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>s</mi><mi>e</mi><mi>g</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">kseg0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">0</span></span></span></span> 段的内核虚拟地址  ： <code>KADDR()</code> ，给物理地址加上  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>80000000</mn></mrow><annotation encoding="application/x-tex">0x80000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> (ULIM的值)</p>
<p>物理地址 ==&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>s</mi><mi>e</mi><mi>g</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">kseg1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">1</span></span></span></span> 段的内核虚拟地址  ：给物理地址加上  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mi>A</mi><mn>0000000</mn></mrow><annotation encoding="application/x-tex">0xA0000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault">A</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h5 id="exercise-5-1-5-2">Exercise 5.1+5.2</h5>
<p>IDE 磁盘驱动程序位于用户空间，但是用户进程不可以直接写内核虚拟地址，故而利用系统调用<code>sys_write_dev</code> 和 <code>sys_read_dev</code> 来实现。</p>
<ul>
<li>
<p><code>syscall_write_dev</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall_write_dev</span><span class="params">(<span class="type">void</span> *va, u_int dev, u_int len)</span>; <span class="comment">//user/lib/syscall_lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span>; <span class="comment">//kern/syscall_all.c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>va</code>：用户虚拟地址</p>
<p><code>dev</code>、<code>pa</code>：设备的物理地址</p>
<p><code>len</code>：读写的长度（按字节计数）</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic_on(syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_ID, <span class="number">4</span>)); <span class="comment">//fs/ide.c</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>syscall_read_dev</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall_read_dev</span><span class="params">(<span class="type">void</span> *va, u_int dev, u_int len)</span>; <span class="comment">//user/lib/syscall_lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span>; <span class="comment">//kern/syscall_all.c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>va</code>：用户虚拟地址</p>
<p><code>dev</code>、<code>pa</code>：设备的物理地址</p>
<p><code>len</code>：读写的长度（按字节计数）</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic_on(syscall_read_dev(dst, DEV_DISK_ADDRESS + DEV_DISK_BUFFER, BY2SECT)); <span class="comment">//fs/ide.c</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-ide磁盘">2、IDE磁盘</h4>
<h5 id="磁盘的物理结构">磁盘的物理结构</h5>
<ol>
<li>扇区 (sector)：扇区是磁盘执行读写操作的单位，一般是 <strong>512 字节</strong>；</li>
<li>磁道 (track): 盘片上以盘片中心为圆心，不同半径的同心圆；</li>
<li>柱面 (cylinder): 硬盘中，不同盘片相同半径的磁道所组成的圆柱面；</li>
<li>磁头 (head): 每个磁盘有两个面，每个面都有一个磁头；</li>
</ol>
<h5 id="ide-磁盘操作">IDE 磁盘操作</h5>
<p>GXemul 提供的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>I</mi><mi>D</mi><mi>E</mi><mi>d</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">Simulated IDE disk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的地址是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>13000000</mn></mrow><annotation encoding="application/x-tex">0x13000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> ，I/O 寄存器各偏移和对应功能如下：</p>
<table>
<thead>
<tr>
<th>偏移</th>
<th>效果</th>
<th>数据位宽</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0000</td>
<td>写：设置下一次读写操作时的磁盘镜像偏移的字节数</td>
<td>4 字节</td>
</tr>
<tr>
<td>0x0008</td>
<td>写：设置高 32 位的偏移的字节数</td>
<td>4 字节</td>
</tr>
<tr>
<td>0x0010</td>
<td>写：设置下一次读写操作的磁盘编号</td>
<td>4 字节</td>
</tr>
<tr>
<td>0x0020</td>
<td>写：开始一次读写操作（写 0 表示读操作， 1 表示写操作）</td>
<td>4 字节</td>
</tr>
<tr>
<td>0x0030</td>
<td>读：获取上一次操作的状态返回值<br>（读 0 表示失败，非 0 则 表示成功）</td>
<td>4 字节</td>
</tr>
<tr>
<td>0x4000~0x41ff</td>
<td>读/写： 512 字节的读写缓存</td>
<td>——</td>
</tr>
</tbody>
</table>
<h4 id="3-驱动程序编写">3、驱动程序编写</h4>
<ul>
<li>
<p><code>read_sector</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">read_sector</span><span class="params">(<span class="type">int</span> diskno, <span class="type">int</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>函数具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># read sector at specified offset from the beginning of the disk image.</span><br><span class="line">LEAF(read_sector)</span><br><span class="line">	sw a0, 0xB3000010 </span><br><span class="line">	# 设置IDE disk的ID,根据函数声明diskno是第一个参数,故而对应$a0寄存器</span><br><span class="line">	# 0xB3000010=0x13000000+0x0010+0xA0000000 存储下一次读写操作的磁盘编号</span><br><span class="line">	# 这句话表示我们将使用编号为 $a0 的磁盘</span><br><span class="line">	sw a1, 0xB3000000 </span><br><span class="line">	# 设置IDE disk的offset,根据函数声明offset是第二个参数,故而对应$a1寄存器</span><br><span class="line">	# 0xB3000000=0x13000000+0xA0000000 存储下一次读写操作时的磁盘镜像偏移的字节数</span><br><span class="line">	# 这句话表示我们将在距离磁盘起始处offset 的位置开始进行磁盘操作</span><br><span class="line">	li t0, 0</span><br><span class="line">	sw t0, 0xB3000020</span><br><span class="line">	# 0xB3000020=0x13000000+0x0020+0xA0000000 选择读/写操作</span><br><span class="line">	# 这两句话置0，表示我们将读磁盘</span><br><span class="line">	lw v0, 0xB3000030</span><br><span class="line">	# 0xB3000030=0x13000000+0x0030+0xA0000000 获取上一次操作的状态返回值</span><br><span class="line">	# 这句话表示将磁盘操作的状态码放入$v0中</span><br><span class="line">	nop</span><br><span class="line">	jr ra</span><br><span class="line">	nop</span><br><span class="line">END(read_sector)</span><br></pre></td></tr></table></figure>
<ul>
<li>当需要<strong>从磁盘的指定位置读取</strong>一个扇区时，<strong>内核驱动</strong>会调用 <code>read_sector</code> 函数来将磁盘中对应 sector 的数据<strong>读到设备缓冲区</strong>中。
<ul>
<li><strong>【注意】 所有的地址操作都需要将物理地址转换成虚拟地址</strong>。此处设备基地址对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>s</mi><mi>e</mi><mi>g</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">kseg1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">1</span></span></span></span> 的内核虚拟地址是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mi>B</mi><mn>3000000</mn></mrow><annotation encoding="application/x-tex">0xB3000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</li>
<li>通过判断 <code>read_sector</code> 函数的返回值，就可以知道读取磁盘的操作是否成功。如果成功，将这个 sector 的数据 (512 bytes) 从设备缓冲区 (offset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>4000</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>41</mn><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x4000-0x41ff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>) 中拷贝到目的位置。至此，就完成了对磁盘的读操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-3">Exercise 5.3</h5>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Question</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>：为什么 <code>ide_read</code> 针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>4000</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>41</mn><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x4000-0x41ff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的操作，是在判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0030</mn></mrow><annotation encoding="application/x-tex">0x0030</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">3</span><span class="mord">0</span></span></span></span> 处状态返回值之<strong>后</strong>进行；相反 <code>ide_write</code> 针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>4000</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>41</mn><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x4000-0x41ff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的操作，是在判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0030</mn></mrow><annotation encoding="application/x-tex">0x0030</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">3</span><span class="mord">0</span></span></span></span> 处状态返回值之<strong>前</strong>进行呢？</p>
<p>答：</p>
<ul>
<li>读的时候 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>4000</mn></mrow><annotation encoding="application/x-tex">0x4000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 这片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">buffer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 是由<strong>硬盘设备</strong>完成写入的，检查 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">status</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span></span></span></span> 是检查<strong>硬盘写入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">buffer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></strong> 有没有问题；</li>
<li>写的时候 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>4000</mn></mrow><annotation encoding="application/x-tex">0x4000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 这片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">buffer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 是由<strong>驱动</strong>完成写入的，检查 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">status</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span></span></span></span> 是检查<strong>驱动写入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">buffer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><strong>有没有问题，所以要</strong>先等驱动写完</strong>。</li>
</ul>
<p>【这里的实现其实因为是在模拟器里面 所以有简化，实际上读status 它有可能返回一些正在操作中的flag，正确方法应该是循环忙等status】</p>
</li>
<li>
<p><code>ide_read()</code> 函数（fs/ide.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span>;</span><br><span class="line"><span class="comment">//diskno: 待操作的磁盘编号</span></span><br><span class="line"><span class="comment">//secno: 第一个待操作的扇区编号</span></span><br><span class="line"><span class="comment">//dst: 读出的数据存到地址为dst的地方去</span></span><br><span class="line"><span class="comment">//nescs: 待操作的扇区数量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：读磁盘</p>
</li>
<li>
<p>实现：使用系统调用，参照 I/O 寄存器各偏移和对应功能赋值</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; int read_block(u_int blockno, void **blk, u_int *isnew)</span></span><br><span class="line">ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK); </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>ide_write()</code> 函数（fs/ide.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span>;</span><br><span class="line"><span class="comment">//diskno: 待操作的磁盘编号</span></span><br><span class="line"><span class="comment">//secno: 第一个待操作的扇区编号</span></span><br><span class="line"><span class="comment">//src: 把地址src处存的内容写到磁盘指定区域去</span></span><br><span class="line"><span class="comment">//nescs: 待操作的扇区数量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：写磁盘</p>
</li>
<li>
<p>实现：使用系统调用，参照 I/O 寄存器各偏移和对应功能赋值</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; void write_block(u_int blockno)</span></span><br><span class="line">de_write(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK); </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="二-文件系统结构">二、文件系统结构</h3>
<p>实现模拟磁盘的驱动程序以及磁盘上和操作系统中的文件系统结构，并实现文件系统操作的相关函数。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">fs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 目录：文件系统服务程序的代码</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">user/lib</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span></span></span></span> 目录的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>c</mi><mtext>、</mtext><mi>f</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>c</mi><mtext>、</mtext><mi>f</mi><mi>s</mi><mi>i</mi><mi>p</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">file.c、fd.c、fsipc.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 文件：文件系统的用户库（允许用户程序调用其中<br>
的函数来操作文件系统  ）
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi>i</mi><mi>p</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">fsipc.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 实现了与文件系统服务进程基于 IPC 的交互</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">file.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 实现了文件系统的用户接口</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">fd.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 实现了文件描述符相关操作</li>
</ul>
</li>
</ul>
<p>文件系统服务进程和其他用户进程之间使用 Lab4 中实现的 IPC机制进行通信。</p>
<h4 id="1-磁盘文件系统布局">1、磁盘文件系统布局</h4>
<ul>
<li>
<p>Block 磁盘块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span> <span class="comment">//tools/fsformat.c</span></span><br><span class="line">	<span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">	<span class="type">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];</span><br></pre></td></tr></table></figure>
<ul>
<li>性质：是虚拟概念，是<strong>操作系统与磁盘==交互==的最小单位</strong>；</li>
<li>目的：减小因扇区过多带来的寻址困难；(潜台词磁盘比扇区大)</li>
<li>构成：操作系统决定磁盘块的大小（通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个扇区），将相邻的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个扇区组合在一起，形成磁盘块进行整体操作；</li>
</ul>
<p>【区分<strong>扇区</strong>】：扇区是真实存在的，是<strong>磁盘==读写==的基本单位</strong>，与操作系统无关。</p>
</li>
<li>
<p>Super Block 超级块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	u_int s_magic; <span class="comment">// 魔数: FS_MAGIC(常量)，标识本文件系统</span></span><br><span class="line">	u_int s_nblocks; <span class="comment">// 1024，为本文件系统的磁盘块个数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// 根目录，f_type = FTYPE_DIR, f_name = &quot;/&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>管理空闲磁盘资源：位图法（Bitmap）</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>f</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">tools/fsformat.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span>​ ：创建符合我们定义的文件系统镜像，将多个文件按照内核所定义的文件系统写入到磁盘镜像中  。</p>
</li>
<li>
<p><code>init_disk</code> 函数（ tools/fsformat.c ）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_disk</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：将所有的块都标记为空闲块</p>
</li>
<li>
<p>实现：计算所有磁盘块数量 ==&gt; 把位图块置1 ==&gt; 把最后一块位图块的靠后一部分置0 ==&gt; 手动初始化值</p>
<p>【注】：如果位图还有剩余，不能将最后一块位图块中靠后的一部分内容标记为空闲，因为这些位所对应的磁盘块并<strong>不存在</strong>，是不可使用的  。</p>
</li>
</ul>
</li>
<li>
<p><code>block_is_free</code> 函数（ fs/fs.c ）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：判断指定磁盘磁盘块是否被占用</p>
</li>
<li>
<p>实现：通过位图中的特定位来判断</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; int read_block(u_int blockno, void **blk, u_int *isnew)</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-4">Exercise 5.4</h5>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Question</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>：为什么参数 <code>blockno</code> 的值不能为 0？</p>
<p>答：因为0号磁盘块存的是<strong>磁盘的信息</strong> ，不可以被清除，也就是不能释放置为空闲。</p>
</li>
<li>
<p><code>free_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：释放磁盘块号为 <code>blockno</code> 的磁盘块，置为空闲，即清除</p>
</li>
<li>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitmap[blockno / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>)); <span class="comment">//把blockno磁盘块的bitmap置空闲</span></span><br><span class="line">bitmap[blockno / <span class="number">32</span>] &amp;= (~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))); <span class="comment">//把blockno磁盘块的bitmap置已用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free_block(bno); <span class="comment">//fs/fs.c ==&gt; int alloc_block(void)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-文件系统详细结构">2、文件系统详细结构</h4>
<ul>
<li>
<p>文件控制块： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">File</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> 结构体（用于描述和管理文件）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// 文件名称,最大长度MAXNAMELEN值为128</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size; <span class="comment">// 文件的大小，单位:字节</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type; <span class="comment">// 文件类型:  普通文件FTYPE_REG，目录FTYPE_DIR</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];<span class="comment">// 文件的直接指针,用来记录文件的数据块在磁盘上的位置</span></span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;<span class="comment">// 指向一个间接磁盘块，用来存储指向文件内容的磁盘块的指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// 指向文件所属的文件目录</span></span><br><span class="line">	<span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">    <span class="comment">//为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>f_type</code>：</p>
<ul>
<li>普通文件 <code>FTYPE_REG</code> ：其指向的磁盘块存储着<strong>文件内容</strong></li>
<li>目录 <code>FTYPE_DIR</code> ：其指向的磁盘块存储着<strong>该目录下各个文件对应的的文件控制块</strong></li>
</ul>
</li>
<li>
<p><code>f_direct[NDIRECT]</code>：</p>
<p>每个文件控制块设有 10 个直接指针;</p>
<p>每个磁盘块的大小为 4KB，所以上述 10 个直接指针能够表示<strong>最大 40KB</strong> 的文件，而当文件的大小大于 40KB 时，就需要用到间接指针。</p>
</li>
<li>
<p><code>f_indirect</code>：</p>
<p>为了简化计算，规定<strong>不使用</strong>间接磁盘块的前十个指针（10个直接指针）。</p>
<ul>
<li>
<p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int i; int bno; struct File *dirf;</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; NDIRECT) &#123;</span><br><span class="line">	bno = dirf-&gt;f_direct[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	bno = (disk[dirf-&gt;f_indirect].data)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<img src="/2023/05/19/BUAA-OS-5/2.png" alt="image-20230511105415482" style="zoom: 67%;">
</li>
<li>
<p>查找某个文件：</p>
<ol>
<li>从<strong>超级块</strong>中读取<strong>根目录的文件控制块</strong>；</li>
<li>沿着目标路径，<strong>挨个</strong>查看当前目录所包含的文件是否与下一级目标文件<strong>同名</strong>，如此便能查找到最终的目标文件。</li>
</ol>
</li>
<li>
<p>镜像文件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>m</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fs.img</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 作用：模拟与真实的磁盘文件设备的交互</p>
</li>
</ul>
<h5 id="exercise-5-5">Exercise 5.5</h5>
<ul>
<li>
<p><code>write_file</code> 函数（tools/fsformat.c）【了解即可】</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_file</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：</p>
<p>​    用于将宿主机上路径为 <code>path</code> 的文件写入磁盘镜像中 <code>dirf</code> 所指向的文件控制块所代表的目录下</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/fsformat.c ==&gt; void write_directory(struct File *dirf, char *path)</span></span><br><span class="line">write_file(pdir, buf);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>write_directory</code> 函数（tools/fsformat.c）【了解即可】</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_directory</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：</p>
<p>​    用于将宿主机上路径为 <code>path</code> 的目录（及其下所有目录和文件）写入磁盘镜像中 <code>dirf</code> 所指向的文件控制块所代表的目录下</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/fsformat.c ==&gt; int main(int argc, char **argv)</span></span><br><span class="line">write_directory(&amp;super.s_root, name);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>create_file</code> 函数（tools/fsformat.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> File *<span class="title function_">create_file</span><span class="params">(<span class="keyword">struct</span> File *dirf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：</p>
<p>在 <code>dirf</code> 指向的文件控制块所代表的目录下分配一个文件控制块，并返回指向新分配的文件控制块的指针</p>
</li>
<li>
<p>实现：</p>
<ol>
<li>遍历 <code>dirf</code> 所代表的目录拥有的每一个磁盘块（包括<strong>直接和间接</strong>指向的磁盘块）；</li>
<li>对每一个磁盘块，从头遍历该磁盘块上的所有文件控制块，找到第一个空的文件控制块并返回该文件控制块指针(空的文件控制块即文件控制块中 <code>f-&gt;f_name[0] == '\0'</code>)  。</li>
</ol>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/fsformat.c ==&gt; void write_directory(struct File *dirf, char *path)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Question</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>： 如何将一个文件或指定目录下的文件按照目录结构写入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>f</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>m</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">target/fs.img</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> ？</p>
<p>答：上面的三个函数。</p>
</li>
<li>
<p><code>make_link_block</code> 函数（tools/fsformat.c）</p>
<ul>
<li>
<p>作用：申请一个新的磁盘块，返回它的 <code>blockno</code> （副作用：已经自动将其归属于 <code>dirf</code> 目录）</p>
</li>
<li>
<p>使用例子：</p>
<p><code>int blockno = make_link_block(dirf, nblk);</code></p>
<p>其中，<code>dirf</code> 是目录的文件控制块；<code>nblk</code> 是前面目录中目前已有的磁盘块数量。</p>
</li>
</ul>
</li>
<li>
<p><code>next_block</code> 函数（tools/fsformat.c）</p>
<ul>
<li>作用：得到下一个空闲磁盘块的 <code>blockno</code>，并将该磁盘块的 <code>type</code> 设置成传入参数的值</li>
<li>使用例子：<code>int bno = next_block(BLOCK_FILE);</code></li>
</ul>
</li>
<li>
<p><code>save_block_link</code> 函数（tools/fsformat.c）</p>
<ul>
<li>作用：将 <code>blockno</code> 对应的磁盘块，连接归属到 <code>dirf</code> 目录中 （【注意】后续需要我们自己额外手动改变 <code>dirf-&gt;f_size += BY2BLK</code> 的大小）</li>
<li>使用例子：<code>save_block_link(dirf, nblk, bno);</code> <code>nblk</code> 是<code>dirf</code>中目前已有的磁盘块数量</li>
</ul>
</li>
</ul>
<h4 id="3-块缓存">3、块缓存</h4>
<p>​       借助虚拟内存来实现磁盘块缓存的设计，<em>文件系统服务</em> 是一个<strong>用户进程</strong>，一个进程可以拥有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的虚拟内存空间，将 <code>DISKMAP ~ DISKMAP+DISKMAX</code> 这一段虚存地址空间 (0x10000000-0x4fffffff) 作为<strong>缓冲区</strong>，当磁盘读入内存时，缓冲区用来<strong>映射相关的页</strong>。</p>
<p>​       建立起磁盘地址空间和进程虚存地址空间之间的缓存映射：<img src="/2023/05/19/BUAA-OS-5/3.png" alt="image-20230514131521632" style="zoom:67%;"></p>
<ul>
<li>
<p><code>read_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：</p>
<ol>
<li>将指定编号的磁盘块读入到内存中，并将 <code>blockno</code> 对应磁盘块的虚拟地址存到 <code>(*blk)</code> 当中；</li>
<li>如果 <code>isnew</code> 是非0的有效地址，就进行操作： 当<code>blockno</code> 对应磁盘块原本就已经 <code>mapped</code> 的时候，就让 <code>*isnew = 0;</code> ，反之，让<code>*isnew = 1;</code></li>
</ol>
</li>
<li>
<p>实现：首先，检查这块磁盘块是否已经在内存中，如果不在，先用 <code>syscall_mem_alloc</code> 分配一页物理内存； 然后调用 <code>ide_read</code> 函数来读取磁盘上的数据到对应的虚存地址处。</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; void read_super(void)</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>write_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：把内存中的 <code>block</code> 的内容写到磁盘<code>disk</code>对应的磁盘块里（两个东东用的是同一个 <code>blockno</code>）</p>
<p>（Write the current contents of the block out to disk.）注意区分 block 和 disk</p>
</li>
<li>
<p>实现：函数 <code>diskaddr</code> 和 <code>ide_write</code></p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_block(blockno);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>file_get_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：令 <code>(*blk)</code> 赋值为<em>文件控制块 <code>f</code> 对应的文件</em> 的第 <code>filebno</code> 个磁盘块 （即将某个指定的文件指向的磁盘块读入内存）</p>
</li>
<li>
<p>实现：首先为即将读入内存的磁盘块利用函数 <code>file_map_block</code> 分配物理内存，然后使用 <code>read_block</code> 函数将磁盘内容<strong>以块为单位</strong>读入内存中的相应位置。</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; int dir_alloc_file(struct File *dir, struct File **file)</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>file_map_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：令 <code>(*diskbno)</code> 赋值为 <em>文件控制块 <code>f</code> 对应的文件</em> 的第 <code>filebno</code> 个磁盘块的 “disk block number” 。如果前面的磁盘块还不存在，且 <code>alloc == 1</code> 则当场给它分配一个。</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; int file_get_block(struct File *f, u_int filebno, void **blk)</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>file_block_walk</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">uint32_t</span> **ppdiskbno, u_int alloc)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：找 + 可能申请 maybe？</p>
</li>
</ul>
</li>
<li>
<p><code>alloc_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：Allocate a block – first find a free block in the bitmap, then map it into memory</p>
</li>
</ul>
</li>
<li>
<p><code>block_is_mapped</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：若<code>blockno</code>已经mapped，就返回它的虚拟缓存地址；反之，返回 <code>NULL</code></p>
</li>
<li>
<p>使用例子：<code>void *va = block_is_mapped(blockno);</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-6">Exercise 5.6</h5>
<ul>
<li>
<p><code>diskaddr</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：根据一个块的序号 (block number)，计算这一磁盘块对应的<strong>虚存</strong>的起始地址</p>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; void *block_is_mapped(u_int blockno)</span></span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-7">Exercise 5.7</h5>
<ul>
<li>
<p><code>map_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：分配映射磁盘块需要的物理页面</p>
</li>
<li>
<p>实现：</p>
<ol>
<li>先使用 <code>block_is_mapped</code> 查看 <code>blockno</code> 对应磁盘块是否已被映射到内存，若已经建立了映射，直接返回 0 即可；</li>
<li>若没有建立映射，则调用 <code>syscall_mem_alloc</code> 函数分配一页物理页面。注意使用 <code>diskaddr</code> 函数将<code>blockno</code> 转换为对应虚拟地址后再传入 <code>syscall_mem_alloc</code> 函数</li>
</ol>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; int alloc_block(void)</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>unmap_block</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：回收用来映射磁盘块的物理页面</p>
</li>
<li>
<p>实现：</p>
<ol>
<li>首先使用 <code>block_is_mapped</code> 函数获取对应磁盘块的虚拟起始地址；</li>
<li>如果该磁盘块不是空闲的（调用 <code>block_is_free</code> 函数）并且该磁盘块缓存被写过（调用<br>
<code>block_is_dirty</code> 函数），就调用 <code>write_block</code> 函数将磁盘块<strong>缓存</strong>写入磁盘<strong>disk</strong>。</li>
<li>最后调用 <code>syscall_mem_unmap</code> 函数解除对应磁盘块缓存虚拟页面到物理页面的映射</li>
</ol>
</li>
<li>
<p>使用例子：同 <code>map_block()</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-8">Exercise 5.8</h5>
<ul>
<li>
<p><code>dir_lookup</code> 函数（fs/fs.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：在 <code>dir</code> 指向的文件控制块所代表的目录下寻找名为 <code>name</code> 的文件，如果找到了，就把它记录给<code>(*file)</code></p>
</li>
<li>
<p>实现：对每一个 <code>dir</code> 指向的文件控制块所管理的磁盘块进行以下操作：</p>
<ol>
<li>使用 <code>file_get_block</code> 函数获取该磁盘块；</li>
<li>遍历该磁盘块上存储的所有文件控制块，如果存在某个文件控制块的 <code>f_name</code> 属性与 <code>name</code> 相同，就将 <code>*file</code> 设为该文件控制块，并返回 0。</li>
</ol>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c ==&gt; int walk_path(char *path, struct File **pdir, struct File **pfile, char *lastelem)</span></span><br><span class="line"><span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="三-文件系统的用户接口">三、文件系统的用户接口</h3>
<p>为用户提供接口和机制使得用户程序能够使用文件系统，这主要通过一个用户态的文件系统服务来实现。</p>
<h4 id="1-文件描述符">1、文件描述符</h4>
<p>引入文件描述符等结构来抽象地表示一个进程所打开的文件，而不必关心文件实际的物理表示，是用户程序管理、操作文件的基础。</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">File Discripter</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">fd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">d</span></span></span></span>，文件描述符</p>
<p>是系统给用户提供的<strong>整数</strong>，用于其在<strong>描述符表</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Descriptor Table</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>) 中进行<strong>索引</strong>。</p>
<ul>
<li>
<p>我们在作为操作系统的 <em>使用者</em> 进行文件 I/O 编程时，使用 <code>open</code> 在描述符表的指定位置存放被打开文件的信息；使用 <code>close</code> 将描述符表中指定位置的文件信息释放；在 <code>write</code> 和 <code>read</code> 时修改描述符表指定位置的文件信息。这里的【指定位置】即【文件描述符 fd】。</p>
</li>
<li>
<p>当用户进程试图打开一个文件时，文件系统服务进程需要一个文件描述符来<strong>存储文件的基本信息和用户进程中关于文件的状态</strong>；同时，文件描述符也起到<strong>描述用户对于文件操作</strong>的作用。</p>
<p>当用户进程向文件系统发送打开文件的请求时，文件系统进程会将这些基本信息记录在内存中， 然后由操作系统将用户进程请求的地址<strong>映射到同一个存储了</strong>文件描述符的物理页上（此部分代码位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">serv.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 的 <code>serve_open</code> 函数内），因此==一个文件描述符至少需要独占一页的空间==。</p>
<p>当用户进程获取了<strong>文件大小等基本信息</strong>后，<strong>再次</strong>向文件系统发送请求将文件内容映射到指定内存空间中。</p>
</li>
</ul>
</li>
<li>
<p><code>struct Fd</code> 结构体 和 <code>struct Filefd</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Filefd</code> 结构体的第一个成员就是 <code>Fd</code>，因此<strong>指向 Filefd 的指针同样指向这个 Fd 的起始位置</strong>，故可以进行<strong>强制转换</strong>。而转换的结果==仅仅是改变了该指针对一段内存的解释方式==。</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-9">Exercise 5.9</h5>
<ul>
<li>
<p><code>open</code> 函数（user\lib\file.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：接受文件路径 <code>path</code> 和模式 <code>mode</code> 作为输入参数，并返回文件描述符的编号</p>
</li>
<li>
<p>实现：</p>
<ol>
<li>首先使用 <code>fd_alloc</code> 和 <code>fsipc_open</code> 函数分配一个文件描述符；</li>
<li>之后使用 <code>fd2data</code> 函数获取文件描述符对应的<strong>数据缓存页地址</strong>，并从 <code>Filefd</code> 结构体中获取文件的 <code>size</code>和 <code>fileid</code> 属性；</li>
<li>之后遍历文件内容，使用 <code>fsipc_map</code> 函数为文件内容<strong>分配页面并映射</strong>；</li>
<li>最后使用 <code>fd2num</code> 函数返回<strong>文件描述符的编号</strong>。</li>
</ol>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/fsformat.c ==&gt; void write_file(...)</span></span><br><span class="line"><span class="type">int</span> fd = open(path, O_RDONLY);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="exercise-5-10">Exercise 5.10</h5>
<p>在多次读写同一文件描述符期间，我们希望能够从文件中<strong>前一次读写完毕的位置</strong>开始，继续读写数据。因此，文件描述符中需要维护一个指针，以帮助我们在文件中定位；在 实现 <code>read</code>、<code>write</code> 和 <code>seek</code> 等操作时，也需要更新该指针的值。</p>
<ul>
<li>
<p><code>write</code> 函数（user\lib\fd.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">const</span> <span class="type">void</span> *buf, u_int n)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：</p>
</li>
<li>
<p>实现：</p>
</li>
<li>
<p>使用例子：</p>
</li>
</ul>
</li>
<li>
<p><code>read</code> 函数（user\lib\fd.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：接收一个文件描述符编号 <code>fdnum</code> ，一个缓冲区指针 <code>buf</code> 和一个最大读取字节数 <code>n</code> 作为输入参数，返回<strong>成功读取的字节数</strong>，并<strong>更新文件描述符的偏移量</strong>。</p>
</li>
<li>
<p>实现：</p>
<ol>
<li>首先使用 <code>fd_lookup</code> 和 <code>dev_lookup</code> 函数获取<strong>文件描述符</strong>和<strong>设备结构体</strong>。如果查找失败，则返回错误码；</li>
<li>接下来，函数检查文件描述符的打开模式是否允许读取操作；</li>
<li>然后，函数调用设备的读取函数 <code>dev_read</code> 从文件当前的偏移位置读取数据到缓冲区中；</li>
<li>最后，如果读取操作成功，则函数更新文件描述符的偏移量并返回成功读取的字节数；</li>
</ol>
</li>
<li>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/lib/fd.c ==&gt; int readn(int fdnum, void *buf, u_int n)</span></span><br><span class="line"><span class="keyword">for</span> (tot = <span class="number">0</span>; tot &lt; n; tot += m) &#123;</span><br><span class="line">	m = read(fdnum, (<span class="type">char</span> *)buf + tot, n - tot);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-文件系统服务">2、文件系统服务</h4>
<p>MOS 操作系统中的文件系统服务通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">IPC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的形式供其他进程调用，进行文件读写操作。</p>
<p>具体来说，在内核开始运行时，就启动了文件系统服务进程 <code>ENV_CREATE</code> ( <code>fs_serv</code> )，用户进程需要进行文件操作时，使用 <code>ipc_send</code>、<code>ipc_recv</code> 与 <code>fs_serv</code> 进行交互，完成操作。</p>
<p><code>fs/serv.c</code> 中服务进程的<strong>主函数</strong>首先调用了 <code>serve_init</code> 函数准备好<strong>全局的文件打开记录表 <code>opentab</code></strong>；然后调用 <code>fs_init</code> 函数来<strong>初始化文件系统</strong>；执行完文件系统的初始化后，调用 <code>serve</code> 函数，文件系统服务<strong>开始运行，等待其他程序的请求</strong>。</p>
<ul>
<li>
<p><code>fs_init</code> 函数首先通过<strong>读取超级块</strong>的内容获知磁盘的基本信息；然后检查磁盘<strong>是否能够正常读写</strong>；最后调用 <code>read_bitmap</code> 函数检查磁盘块上的<strong>位图是否正确</strong>。</p>
</li>
<li>
<p>用户程序在发出文件系统操作请求时，将请求的内容放在对应的<strong>结构体</strong>中进行消息的传递， <code>fs_serv</code> 进程收到其他进行的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">IPC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 请求后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">IPC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 传递的消息包含了 <em>请求的类型</em> 和 <em>其他必要的参数</em>，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果<strong>重新通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">IPC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 反馈</strong>给用户程序。</p>
</li>
</ul>
<h5 id="exercise-5-11-5-12-5-13">Exercise 5.11 + 5.12 + 5.13</h5>
<ul>
<li>
<p><code>user/lib/fsipc.c</code> ：定义了请求文件系统时用到的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">IPC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 操作</p>
<p><code>user/lib/file.c</code> ：定义了用户程序读写、创建、删除和修改文件的接口</p>
</li>
<li>
<p><code>serve_remove</code> 函数 （fs/serv.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_remove</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_remove *rq)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：Serve to remove a file specified by the path in <code>rq</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>fsipc_remove</code> 函数 （user/lib/fsipc.c）</p>
<ul>
<li>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>作用：实现了一个客户端向 <code>fs_serv</code> 进程发送删除文件请求的功能。它接收一个文件路径字符串作为参数，并返回删除操作的结果。</p>
</li>
<li>
<p>实现：</p>
<ol>
<li>首先检查路径字符串的长度是否在0到 MAXPATHLEN 之间。如果不是，则返回错误码，表示路径字符串不合法；</li>
<li>接下来，函数将 IPC 缓冲区 <code>fsipcbuf</code> 视为一个 <code>Fsreq_remove</code> 结构体，代表将要发送的是 <code>remove</code> 请求，并将路径字符串复制到结构体的路径字段中；</li>
<li>最后，函数使用 <code>fsipc</code> 函数将删除请求发送到 <code>fs_serv</code> 进程，并返回删除操作的结果。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="难点分析">难点分析</h2>
<p><img src="/2023/05/19/BUAA-OS-5/4.png" alt="2c9cbb5eeb11dc26dbcd921ad8a222e"></p>
<ul>
<li>
<p>文件控制块—— <code>BY2FILE</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">256B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>
<p>扇区——  <code>BY2SECT</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">512B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>
<p>磁盘块——<code>BY2BLK</code> = <code>BY2PG</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>
<p>一个磁盘块中的扇区数量—— <code>SECT2BLK</code> = <code>(BY2BLK / BY2SECT)</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span></p>
<p>缓冲区—— <code>DISKMAP</code> ~ <code>DISKMAP+DISKMAX</code>  =  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>10000000</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>4</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x10000000-0x4fffffff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></p>
</li>
<li>
<p>一个目录 = 一个磁盘块全部用来存目录项</p>
<p>一个目录项 = 指向一个磁盘块</p>
<p>一个磁盘块 = 16个文件控制块</p>
<p>一个文件控制块 = 描述一个文件</p>
<p>一个文件有 <strong>直接指针 + 间接指针</strong> 共1024个 ，每个指针指向一个磁盘块 = 存储着该文件的一部分文件数据</p>
</li>
<li>
<p>由 <code>struct File *dirf</code> （<strong>指向的文件控制块代表一个目录</strong>）引发的一系列操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dirf</span>;</span> <span class="comment">//假设已知 【dir_lookup是个好东西】</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//该目录下磁盘块的数量</span></span><br><span class="line"><span class="type">int</span> nblk = dirf-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历该目录下所有的磁盘块，得到对应的blockno</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblk; ++i) &#123;</span><br><span class="line">	<span class="type">int</span> bno; </span><br><span class="line">	<span class="keyword">if</span> (i &lt; NDIRECT) &#123;</span><br><span class="line">		bno = dirf-&gt;f_direct[i];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bno = (disk[dirf-&gt;f_indirect].data)[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历该目录下所有的磁盘块，得到对应磁盘的文件控制块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblk; ++i) &#123;</span><br><span class="line">    <span class="type">void</span> *blk;</span><br><span class="line">	try(file_get_block(dirf, i, &amp;blk));</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由blockno得到对应磁盘的文件控制块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//由blk，遍历磁盘块上的所有文件控制块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> File *f = blk; f &lt; blk + FILE2BLK; ++f) &#123;</span><br><span class="line">	<span class="comment">//对f......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据某磁盘的文件控制块，判断该文件是否为空</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请一个新的磁盘块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[make_link_block(dirf, nblk)].data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//由指向某磁盘块的文件控制块，得到该磁盘块中的第一个文件控制块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span> =</span> blk;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一个 <code>blockno</code> 对应了两个地方：</p>
<ul>
<li>
<p>用户进程 <em>文件系统服务</em> 的虚拟缓存，里面有一块内存写的<code>blockno</code> 磁盘块的临时内容;</p>
<p>用 <code>void *va = diskaddr(blockno);</code></p>
</li>
<li>
<p>同时，<code>disk</code> 磁盘中，对应的 <code>blockno</code> 磁盘块，是它实际模拟的硬件部分;</p>
<p>用 <code>blockno * SECT2BLK</code> 表示它的第一个扇区</p>
</li>
</ul>
<p>​    合作使用有：<code>ide_write(0, blockno * SECT2BLK, va, SECT2BLK);</code> 【但还是直接用<code>write_block</code> 吧】</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">fs/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">/</span></span></span></span> 下部分函数的调用关系：【文件系统结构中的部分函数】</p>
<img src="/2023/05/19/BUAA-OS-5/5.png" alt="image-20230514144459530" style="zoom:67%;">
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">user/lib/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">/</span></span></span></span> 下部分函数调用关系：【文件系统的用户接口中的部分函数】</p>
<img src="/2023/05/19/BUAA-OS-5/6.png" alt="image-20230515123748971" style="zoom:67%;">
</li>
</ul>
<h4 id="往年题lab5-1-exam">往年题lab5-1-exam</h4>
<p>花叶学长的答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/ide.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">time_read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (syscall_read_dev((u_int) &amp; time, <span class="number">0x15000000</span>, <span class="number">4</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        user_panic(<span class="string">&quot;time_read panic&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (syscall_read_dev((u_int) &amp; time, <span class="number">0x15000010</span>, <span class="number">4</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        user_panic(<span class="string">&quot;time_read panic&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">raid0_write</span><span class="params">(u_int secno, <span class="type">void</span> *src, u_int nsecs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = secno; i &lt; secno + nsecs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ide_write(<span class="number">1</span>, i / <span class="number">2</span>, src + (i - secno) * <span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ide_write(<span class="number">2</span>, i / <span class="number">2</span>, src + (i - secno) * <span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">raid0_read</span><span class="params">(u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = secno; i &lt; secno + nsecs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ide_read(<span class="number">1</span>, i / <span class="number">2</span>, dst + (i - secno) * <span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ide_read(<span class="number">2</span>, i / <span class="number">2</span>, dst + (i - secno) * <span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="往年题lab5-1-extra">往年题lab5-1-extra</h4>
<p>花叶学长的答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/ide.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raid4_valid</span><span class="params">(u_int diskno)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !ide_read(diskno, <span class="number">0</span>, (<span class="type">void</span> *) <span class="number">0x13004000</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXL (128)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raid4_write</span><span class="params">(u_int blockno, <span class="type">void</span> *src)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> invalid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> check[MAXL];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (raid4_valid(i % <span class="number">4</span> + <span class="number">1</span>)) &#123;</span><br><span class="line">            ide_write(i % <span class="number">4</span> + <span class="number">1</span>, <span class="number">2</span> * blockno + i / <span class="number">4</span>, src + i * <span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; invalid++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!raid4_valid(<span class="number">5</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invalid / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAXL; j++) &#123;</span><br><span class="line">            check[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                check[j] ^= *(<span class="type">int</span> *) (src + (<span class="number">4</span> * i + k) * <span class="number">0x200</span> + j * <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ide_write(<span class="number">5</span>, <span class="number">2</span> * blockno + i, (<span class="type">void</span> *) check, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invalid / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raid4_read</span><span class="params">(u_int blockno, <span class="type">void</span> *dst)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> invalid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> wrong = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> check[<span class="number">2</span> * MAXL];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!raid4_valid(i)) &#123;</span><br><span class="line">            invalid++;</span><br><span class="line">            wrong = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (invalid &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invalid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">4</span> + <span class="number">1</span> != wrong) &#123;</span><br><span class="line">            ide_read(i % <span class="number">4</span> + <span class="number">1</span>, <span class="number">2</span> * blockno + i / <span class="number">4</span>, dst + i * <span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wrong == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    ide_read(<span class="number">5</span>, <span class="number">2</span> * blockno, check, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAXL; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                check[i * MAXL + j] ^= *(<span class="type">int</span> *) (dst + (<span class="number">4</span> * i + k) * <span class="number">0x200</span> + j * <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!wrong) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span> * MAXL; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wrong--;</span><br><span class="line">    user_bcopy(check, dst + wrong * <span class="number">0x200</span>, <span class="number">0x200</span>);</span><br><span class="line">    user_bcopy((<span class="type">void</span> *) check + <span class="number">0x200</span>, dst + <span class="number">0x800</span> + wrong * <span class="number">0x200</span>, <span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课上测试">课上测试</h3>
<h4 id="lab5-1-exam">lab5-1-Exam</h4>
<p>考察类似于 <code>ide_read()</code> 仿写，题目给的步骤很清晰，一步一步使用 <code>syscall_read_dev()</code> 或 <code>syscall_write_dev()</code> 系统调用实现即可。</p>
<h4 id="lab5-1-extra">lab5-1-Extra</h4>
<p>本题考察 <code>ide_read()</code> 和 <code>ide_write()</code> 函数的应用，实现一个简单的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">SSD</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> ，具体题目见文章 <a target="_blank" rel="noopener" href="https://yanna-zy.gitee.io/file/2023-BUAA-OS-5-ExtraStem.pdf">Lab5-1-Extra-SSD题干</a>。</p>
<p>引入三个全局变量，分别表示<strong>闪存映射表</strong>、<strong>物理块位图</strong>、<strong>物理块累计擦除次数表</strong>即可。</p>
<ul>
<li>
<p>我的答案：【又一次感激涕零~ 题干描述清晰无歧义，也贴心地告诉了我们要“怎么实现？” “实现注意点？” 贴心得不得了~~】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">u_int ssdtable[<span class="number">32</span>];</span><br><span class="line">u_int ssdbitmap[<span class="number">32</span>];<span class="comment">//1 可写</span></span><br><span class="line">u_int ssdnum[<span class="number">32</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssd_init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">		ssdtable[i] = <span class="number">0xffffffff</span>;</span><br><span class="line">		ssdbitmap[i] = <span class="number">1</span>;</span><br><span class="line">		ssdnum[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ssd_read</span><span class="params">(u_int logic_no, <span class="type">void</span> *dst)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ssdtable[logic_no] == <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ide_read(<span class="number">0</span>, ssdtable[logic_no], dst, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssd_write</span><span class="params">(u_int logic_no, <span class="type">void</span> *src)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ssdtable[logic_no] != <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">		ssd_erase(logic_no);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//alloc----------------------</span></span><br><span class="line">	u_int physical_no = <span class="number">0xffffffff</span>;</span><br><span class="line">	<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ssdbitmap[i] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (physical_no == <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">				physical_no = i;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (ssdnum[i] &lt; ssdnum[physical_no])</span><br><span class="line">					physical_no = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ssdnum[physical_no] &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">		u_int help_no = <span class="number">0xffffffff</span>;</span><br><span class="line">		u_int help_logic = <span class="number">0xffffffff</span>;</span><br><span class="line">		<span class="keyword">for</span>(u_int i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ssdbitmap[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (help_no == <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">					help_no = i;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (ssdnum[i] &lt; ssdnum[help_no])</span><br><span class="line">						help_no = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) </span><br><span class="line">			<span class="keyword">if</span> (ssdtable[i] == help_no) &#123;</span><br><span class="line">				help_logic = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		u_int help_data[<span class="number">128</span>];</span><br><span class="line">		<span class="keyword">if</span> (ssd_read(help_logic, (<span class="type">void</span> *)help_data) != <span class="number">0</span>)</span><br><span class="line">			user_panic(<span class="string">&quot;wrong in ssd_write&#x27;s help_data\n&quot;</span>);</span><br><span class="line">		ide_write(<span class="number">0</span>, physical_no, (<span class="type">void</span> *)help_data, <span class="number">1</span>);</span><br><span class="line">		ssdbitmap[physical_no] = <span class="number">0</span>;</span><br><span class="line">		ssd_erase(help_logic);</span><br><span class="line">		ssdtable[help_logic] = physical_no;</span><br><span class="line">		physical_no = help_no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//---------------------------</span></span><br><span class="line">	ssdtable[logic_no] = physical_no;</span><br><span class="line">	ide_write(<span class="number">0</span>, physical_no, src, <span class="number">1</span>);</span><br><span class="line">	ssdbitmap[physical_no] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssd_erase</span><span class="params">(u_int logic_no)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ssdtable[logic_no] == <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//all 0 in 物理块------------</span></span><br><span class="line">	u_int zero[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">		zero[i] = <span class="number">0</span>;</span><br><span class="line">	ide_write(<span class="number">0</span>, ssdtable[logic_no], (<span class="type">void</span> *)zero, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//---------------------------</span></span><br><span class="line">	ssdnum[ssdtable[logic_no]]++;</span><br><span class="line">	ssdbitmap[ssdtable[logic_no]] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ssdtable[logic_no] = <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="lab5-2-exam">lab5-2-Exam</h4>
<p>我们在课下已经实现了函数 <code>int open(const char *path, int mode)</code> ，利用<strong>绝对路径</strong>（相对于根目录的路径）path 定位文件。在实际的用户程序中，完成同一任务时打开的多个文件往往存储在同一目录下，然而系统每次打开文件时都需要从根目录开始查找路径，从而重复访问相同的目录。</p>
<p>在本次题中，要求实现 <code>int openat(int dirfd, const char *path, int mode)</code> 函数，利用相对于目录 <code>dirfd</code> 的相对路径 <code>path</code> 定位并打开文件，其中文件描述符 <code>dirfd</code> 指向已通过 <code>open()</code> 打开的目录。相对路径 <code>path</code> 也可能包含路径分隔符 <code>/</code>，表示查找目录 <code>dirfd</code> 下嵌套的目录中的文件。</p>
<ul>
<li>
<p>实现思路：</p>
<ul>
<li>
<p>在 user/include/fsreq.h 中增加一个对于文件系统的请求类型 <code>#define FSREQ_OPENAT 8</code> 和请求结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_openat</span> &#123;</span></span><br><span class="line">  	u_int dir_fileid;</span><br><span class="line">  	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">  	u_int req_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 user/lib/fsipc.c 中仿照 <code>fsipc_open</code> 实现 <code>int fsipc_openat(u_int dir_fileid, const char *path, u_int omode, struct Fd *fd)</code>，完成对 <code>Fsreq_openat</code> 各个字段的赋值，并与文件系统服务进程进行通信。</p>
</li>
<li>
<p>在 user/lib/file.c 中仿照 <code>open</code> 函数实现 <code>int openat(int dirfd, const char *path, int mode)</code>，实现这一函数的相关提示：</p>
<ul>
<li>调用 <code>fd_lookup</code> 利用 <code>dirfd</code> 查找 <code>dirfd</code> 的文件描述符 <code>struct Fd *dir</code></li>
<li>将 <code>struct Fd *dir</code> 指向的类型转换为 <code>struct Filefd</code> 后获得 <code>dirfd</code> 对应的 <code>fileid</code></li>
<li>调用 <code>fsipc_openat</code> 打开文件并完成对指针 <code>fd</code> 的赋值。</li>
</ul>
</li>
<li>
<p>在 fs/fs.c 中，仿照 <code>walk_path</code> 实现 <code>int walk_path_at(struct File *par_dir, char *path, struct File **pdir, struct File **pfile, char *lastelem)</code>；</p>
<p>在 <code>par_dir</code> 目录下按相对路径 <code>path</code> 查找文件，并仿照 <code>file_open</code> 实现 <code>int file_openat(struct File *dir, char *path, struct File **file)</code> 调用 <code>walk_path_at</code> 函数。</p>
</li>
<li>
<p>在 fs/serv.c 中仿照 <code>serve_open</code> 实现 <code>serve_openat</code> 函数，并在 <code>serve</code> 函数中增加关于 <code>openat</code> 请求的判断。</p>
<ul>
<li>
<p>提示：可以参考以下实现，利用 <code>dir_fileid</code> 查找已经被打开的 <code>dirfd</code> 对应的文件控制块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;dir_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span> =</span> pOpen-&gt;o_file;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>上述函数中，需要在 user/include/lib.h 中增加 <code>int openat(int dirfd, const char *path, int mode)</code> 、 <code>int fsipc_openat(u_int, const char *, u_int, struct Fd *)</code> 函数声明，在 fs/serv.h 中增加 <code>int file_openat(struct File *dir, char *path, struct File **pfile)</code> 函数声明。</p>
</li>
</ul>
</li>
</ul>
<h4 id="lab5-2-extra">lab5-2-Extra</h4>
<p>本题考察修改镜像文件 <code>fsformat</code> 的方式，实现符号链接（Symbolic link），具体题目见文章 <a target="_blank" rel="noopener" href="https://yanna-zy.gitee.io/2023/05/15/BUAA-OS-5-ExtraStem/">Lab5-2-Extra-Symbolic link题干</a>。</p>
<p>【后来发现自己的错误在：题干给的提示没有让修改 user/lib/file.c 中的 <code>open</code> 函数，于是我就没有想到过要修改这个，然后不管我怎么测试修改都不正确，哭唧唧~   这个教训是不要寄所有希望于题干】</p>
<ul>
<li>
<p>鹿煜恒大佬的答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/fsformat.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_symlink</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br><span class="line">	<span class="type">char</span> targetpath[<span class="number">2048</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> len = readlink(path, targetpath, <span class="number">2047</span>);</span><br><span class="line">	<span class="comment">/* in case `create_file` is&#x27;t filled */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(disk[nextbno].data, targetpath, len);</span><br><span class="line">	disk[nextbno].data[len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Get file name with no path prefix.</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fname) &#123;</span><br><span class="line">		fname++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fname = path;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(target-&gt;f_name, fname);</span><br><span class="line"></span><br><span class="line">	target-&gt;f_size = <span class="number">2048</span>;</span><br><span class="line">	target-&gt;f_type = FTYPE_LNK;</span><br><span class="line"></span><br><span class="line">	save_block_link(target, <span class="number">0</span> , next_block(BLOCK_DATA));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user/lib/file.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">	<span class="comment">//......略</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(ffd-&gt;f_file.f_type == FTYPE_LNK)&#123;</span><br><span class="line">		<span class="keyword">return</span> open(fd2data(fd), mode);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="体会与感想">体会与感想</h2>
<p>​       lab5 是OS课程的最后一个有上机考试的单元，终于结束了，十分感动ing~</p>
<p>​       本单元我们成功搭建了一个简单的文件系统，值得注意的是，我们学会了修改镜像文件 <code>fsformat</code> ，也明白了：<em>文件系统服务</em> 本身也是一个<strong>用户进程</strong>。当然，我们实现的仅仅是一个非常简单的系统，实际工程设计中的文件系统远比这个要复杂很多，未来如果想要在这个领域有所建树，还是需要投入大量的时间精力进行学习探究。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">YannaZhang 张杨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/19/BUAA-OS-5/">http://example.com/2023/05/19/BUAA-OS-5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YannaのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA-OS/">BUAA-OS</a></div><div class="post_share"><div class="social-share" data-image="/img/series1/8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/19/BUAA-OO-3/" title="BUAA-OO-第三单元：规格化设计"><img class="cover" src="/img/series1/10.png" onerror="onerror=null;src='/img/archive_img.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OO-第三单元：规格化设计</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/18/BUAA-OS-challenge/" title="BUAA-OS-lab4-challenge"><img class="cover" src="/img/series1/9.png" onerror="onerror=null;src='/img/archive_img.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-lab4-challenge</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/19/BUAA-OS-0/" title="BUAA-OS-lab0"><img class="cover" src="/img/series1/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">BUAA-OS-lab0</div></div></a></div><div><a href="/2023/03/19/BUAA-OS-1/" title="BUAA-OS-lab1"><img class="cover" src="/img/series1/2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">BUAA-OS-lab1</div></div></a></div><div><a href="/2023/04/10/BUAA-OS-2/" title="BUAA-OS-lab2"><img class="cover" src="/img/series1/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">BUAA-OS-lab2</div></div></a></div><div><a href="/2023/04/18/BUAA-OS-3/" title="BUAA-OS-lab3"><img class="cover" src="/img/series1/6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">BUAA-OS-lab3</div></div></a></div><div><a href="/2023/05/15/BUAA-OS-4/" title="BUAA-OS-lab4"><img class="cover" src="/img/series1/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="title">BUAA-OS-lab4</div></div></a></div><div><a href="/2023/06/18/BUAA-OS-challenge/" title="BUAA-OS-lab4-challenge"><img class="cover" src="/img/series1/9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-18</div><div class="title">BUAA-OS-lab4-challenge</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">Lab5实验报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">Thinking 5.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-2"><span class="toc-number">1.1.2.</span> <span class="toc-text">Thinking 5.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-3"><span class="toc-number">1.1.3.</span> <span class="toc-text">Thinking 5.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-4"><span class="toc-number">1.1.4.</span> <span class="toc-text">Thinking 5.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-5"><span class="toc-number">1.1.5.</span> <span class="toc-text">Thinking 5.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-6"><span class="toc-number">1.1.6.</span> <span class="toc-text">Thinking 5.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-5-7"><span class="toc-number">1.1.7.</span> <span class="toc-text">Thinking 5.7</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BD%93%E4%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">实验体会</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">文件系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">文件系统的设计与实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-ide%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">一、IDE磁盘驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mmio%EF%BC%9A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84i-o"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1、MMIO：内存映射I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-1-5-2"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">Exercise 5.1+5.2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ide%E7%A3%81%E7%9B%98"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2、IDE磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">磁盘的物理结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ide-%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">IDE 磁盘操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3、驱动程序编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-3"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">Exercise 5.3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">二、文件系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1、磁盘文件系统布局</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-4"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">Exercise 5.4</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2、文件系统详细结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-5"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">Exercise 5.5</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3、块缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-6"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">Exercise 5.6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-7"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">Exercise 5.7</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-8"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">Exercise 5.8</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">三、文件系统的用户接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1、文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-9"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">Exercise 5.9</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-10"><span class="toc-number">1.2.4.1.2.</span> <span class="toc-text">Exercise 5.10</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2、文件系统服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exercise-5-11-5-12-5-13"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">Exercise 5.11 + 5.12 + 5.13</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">难点分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E9%A2%98lab5-1-exam"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">往年题lab5-1-exam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E9%A2%98lab5-1-extra"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">往年题lab5-1-extra</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">课上测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lab5-1-exam"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">lab5-1-Exam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lab5-1-extra"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">lab5-1-Extra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lab5-2-exam"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">lab5-2-Exam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lab5-2-extra"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">lab5-2-Extra</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E4%BC%9A%E4%B8%8E%E6%84%9F%E6%83%B3"><span class="toc-number">1.4.</span> <span class="toc-text">体会与感想</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/post_img.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By YannaZhang 张杨</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'sVaqAurlJUIUiRSl4GxSzMoi-gzGzoHsz',
      appKey: 'BCXg41m5wCxza144wQyhXZzv',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/sakura.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>